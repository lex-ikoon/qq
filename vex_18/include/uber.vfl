
///------------------------------------------------------------------------------------------------

//-------
int   preview_toggle = chi("preview_toggle"); // toggle parent
//-------
float value_preview  = chf("value_preview"); // 0.5 in 0.0 to 1.0
float value_final    = chf("value_final");   // 0.5 in 0.0 to 1.0

int value_preview    = chi("value_preview"); // 1 in 0 to 10
int value_final      = chi("value_final");   // 1 in 0 to 10

preview( preview_toggle, value_preview, value_final);

--float preview (int preview_toggle; float value_preview, value_final)
{

    if (preview_toggle)
    {
        return value_preview;
    }else{
        return value_final;
    }
}

int preview (int preview_toggle; int value_preview, value_final)
{

    if (preview_toggle)
    {
        return value_preview;
    }else{
        return value_final;
    }
}

///------------------------------------------------------------------------------------------------

clamp01(val);

--void clamp01(float value)
{
    value = clamp(value,0,1);    
}

--float clamp01(float value)
{
    return clamp(value,0,1);    
}


///------------------------------------------------------------------------------------------------


string = ftoa(float)

--string ftoa(float value)
{
    return sprintf("%g", value);
}

///------------------------------------------------------------------------------------------------


int padzero_size   = chi("padzero_size"); // 5 in 1 to 6
int padzero_value  = i@index;
string index       = padzero(padzero_size, padzero_value);

--string padzero(int size, value)
{
        string format = '%0' + itoa(size) + 'd';
        string eval   = sprintf(format, value) ;
        return eval;
}


///------------------------------------------------------------------------------------------------

float array[];
append(array, 20);

blend( array, index );

--float blend( float array[]; float index )
{

    float value_0 , value_1;
    float index_01;
    float eval;

    value_0  = array [floor(       index   )];
    value_1  = array [floor(  ceil(index)  )];
    index_01 = index % 1;

    eval = fit01(index_01, value_0, value_1);

    return eval;
}


///------------------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
/////////           dim               /////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///------------------------------------------------------------------------------------------------


qqgeo_bounding_vector

vector from = result_from;
vector to   = result_to;

//generates unclamped (below 0, above 1)
@dim_falloff = dim_falloff_linear(@P, from, to);


--float dim_falloff_linear(vector pos, from, to)
{
    vector u = normalize(to - from);
    vector v = pos - from;

    float eval = dot(u,v) / length(to - from);
    return eval;
}

///------------------------------------------------------------------------------------------------



qq geo_bounding_vector

vector center = result_from;
vector extent = result_to;

//vector center = chv("center");
//vector extent = chv("extent");


//generates unclamped (below 0, above 1)
@dim_falloff = dim_falloff_radial(@P, center, extent);


--float dim_falloff_radial(vector pos, center, extent)
{
    float max  = length(extent - center);
    float eval = length(pos - center) / max;
    return eval;
}


///------------------------------------------------------------------------------------------------

string class = "point"; //prim
string setname = "u";

--void dim_segment(int geometry; string class, name)
{

    int count;
    float eval;
    if (class == "point")
        count = npoints(0);

    if (class == "prim")
        count = nprimitives(0);
    
    eval = 0;

    for (int elem = 0; elem < count; elem++)
    {
        setdetailattrib(0,name,eval);
    }

}

///------------------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
/////////         distort             /////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///------------------------------------------------------------------------------------------------


float bias = chf("bias"); // 0.5 in 0 to 1
float ease = chf("ease"); // 0.5 in 0 to 1

distort_bias(@dim_falloff, bias);
distort_ease(@dim_falloff, ease);

--void distort_bias(float dimension, bias) 
{
    if (dimension <= 0)
        dimension = 0;
    else if (dimension >= 1)
        dimension = 1;
    else
        dimension = (1-bias) / (((1.0 / dimension) - 2) * (bias) + 1);
}

float distort_bias(float dimension, bias) 
{
    float eval;
    if (dimension <= 0)
        eval = 0;
    else if (dimension >= 1)
        eval = 1;
    else
        eval = (1-bias) / (((1.0 / dimension) - 2) * (bias) + 1);
    return eval;
}

///------------------------------------------------------------------------------------------------


float bias = chf("bias"); // 0.5 in 0 to 1
float ease = chf("ease"); // 0.5 in 0 to 1

dimension = distort_bias(@dim_falloff, bias);
dimension = distort_ease(@dim_falloff, ease);

--void distort_ease(float dimension, ease) 
{
    if(dimension<0.5)
        dimension = distort_bias(dimension*2,ease)/2;
    else
        dimension = 1 - distort_bias((1-dimension)*2,ease)/2;
}


///------------------------------------------------------------------------------------------------

//--------
// ramp UI
// chramp("where_the_noise") // ends
//--------
int limit_impact = chi("limit_impact"); //toggle
//# when limit_impact is on, then ends can be 1.0

qq noise_fstat

distort_noise(@dim_falloff, noise, limit_impact, "where_the_noise");

--void distort_noise(float dimension, noise; int limit_impact; string channel)
{
    float impact = chramp(channel, dimension);

    if (limit_impact)
    {
        // triangle
        float limit_from_top = 1 - dimension;
        float limit_from_bot =     dimension;
        impact *= min(limit_from_top, limit_from_bot);
    } 

    dimension = dimension + impact * noise;
}


///------------------------------------------------------------------------------------------------

//--------
// ramp UI
// chramp("dimension_lut") // tri_rl


distort_lut(@dim_falloff, "dimension_lut");

--void distort_lut(float dimension; string channel)
{
    dimension = chramp(channel, dimension);
}


///------------------------------------------------------------------------------------------------


//----
float from_zero  = chf("from_zero"); // 0 in 0 to 1
float from_one = chf("from_one"); // 1 in 0 to 1
//#   dont make left bigger than right

// optional noise
// qqnoise_ fstat
// from_zero = noise_fstat ( dimension, f, offset, turb, rough, atten, amp );

distort_shrink(@dim_falloff, from_zero, from_one);

--void distort_shrink(float dimension, from_zero, from_one) 
{
    dimension = fit(dimension, from_zero, from_one, 0, 1);
}


///------------------------------------------------------------------------------------------------

// UI
//----
string segment_attname = chs("name"); // letters etc.
string segment_maxname = chs("name") + "_max";
//----
float offset_0  = chf("offset_0"); // 0 in 0 to 1
float offset_1  = chf("offset_1"); // 1 in 0 to 1
int enable_gaps = chi("enable_gaps"); // toggle

//get segment_rel
int primitives[]  = pointprims(0, @ptnum);
int segment       =   prim(0, segment_attname, primitives[0]);
int segment_max   = detail(0, segment_maxname) ;

distort_segment(@dim_falloff, segment, segment_max, offset_0, offset_1, enable_gaps);


--void distort_segment(float dimension; int segment, segment_max; float offset_0, offset_1; int enable_gaps)
{

    float segment_rel = float (segment) / float(segment_max);
    float off_0, off_1;

    if (enable_gaps)
    {
        off_0 = min(offset_0,0.99999);
        off_1 = max(offset_1,0.00001);
    } 
    else
    {
        // correct offset to not overlap
        off_0 = fit01( offset_0,         0         ,  1-1/float(segment_max+1) );
        off_1 = fit01( offset_1, 1/float(segment_max+1) ,            1         );
    }

    float wide_min = segment_rel * off_0;
    float wide_max = 1-(1-segment_rel) * (1-off_1);

    dimension = fit(dimension, wide_min, wide_max, 0, 1);

}


///------------------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
/////////        coord   music        /////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///------------------------------------------------------------------------------------------------

int    pitch = 0;

@Cd = coord_midi("midi_beat", pitch, @Frame);


--float coord_midi(string name; float pitch, time)
{
    string geo       = "op:/obj/midi/mixer/" + name;
    float i[]        = detail(geo, name);
    int midi_total_frames = detail(geo, "midi_total_frames");
    int index        = floor(time) + midi_total_frames * floor(pitch);
    
    float result     = i[index];
    return result;
}

///------------------------------------------------------------------------------------------------

string track = "beat";
string array = "posamp"; //preamp, poslin, prelin
int    pitch = 0;
int    clone = 0;
int    frame = int(@Frame);

float amp = coord_music(track, array, pitch, clone, frame);
@Cd *= amp;

--float coord_music(string track, array; int pitch, clone, frame)
{
    float  amp;
    string path    = "op:/obj/music/tracks/" + track + "/vex/" + array;
    int    pitches = detail(path,"track_pitches",0);
    int    first   = detail(path,"array_frame_first",0);
    int    prim    = pitch + (clone * pitches);
    vector vertex  = vertex(path, "P", prim, frame-first);
           amp     = vertex[1];
    return amp;
}


///------------------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
/////////            fill             /////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///------------------------------------------------------------------------------------------------


float dimension = @dim_falloff;
float coord = @coord;
float feather_spread = chf("feather_spread"); // 0.5 in 0 to 1

float fill = fill_to_coord(dimension, coord, feather_spread);


--float fill_to_coord(float dimension, coord, feather_spread) //clamped
{
    float eval, trywide;
    trywide = fit01(coord, -feather_spread/2 , 1+feather_spread/2);

    if ( feather_spread>0 )
    {
        float omin = dimension - feather_spread/2;
        float omax = dimension + feather_spread/2;
        eval = fit(trywide, omin, omax, 0, 1);
    } else {
        if ( trywide > dimension )
        {
            eval = 1;
        } else {
            eval = 0;
        }
    }

    if (coord == 1) eval = 1;
    if (coord == 0) eval = 0;

    return eval;
}

///------------------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
/////////            geo              /////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///------------------------------------------------------------------------------------------------



float u = geo_line_u (0, @ptnum);

--float geo_line_u (int geometry, ptnum)
{
    
    // TODO
    // int vtx = vertexprimindex(0, @vtxnum);
    // int nvtx = primvertexcount(0, @primnum);
    // f@u = (float)vtx/(@numvtx-1);

    int linvert   = pointvertex (geometry, ptnum);
    int vertex    = vertexprimindex (geometry, linvert);
    int primnum[] = pointprims (geometry, ptnum);
    int count     = primvertexcount (geometry, primnum[0]);
    
    float eval    = vertex / float (count-1);

    return eval;
}


///------------------------------------------------------------------------------------------------

int geometry = 0;
int primnum  = @primnum;
float u      = (@Time*0.1*random(@primnum)+random(@primnum)) %1;

// reads and sets N, up
// sets f@u

geo_carve_point (geometry, primnum, u);

--void geo_carve_point (int geometry, primnum; float u)
{
    int oldprim = primnum;
    vector pos  = primuv(0, "P", primnum, set(u,0,0));
    vector N    = primuv(0, "N", primnum, set(u,0,0));
    vector up   = primuv(0, "up", primnum, set(u,0,0));
    
    int ptnum   = addpoint(0, pos);

    setpointattrib(0, "N", ptnum, N, "set");
    setpointattrib(0, "up", ptnum, up, "set");
    setpointattrib(0, "u", ptnum, u, "set");
    
    removeprim  (geometry, oldprim, 1);
}


///------------------------------------------------------------------------------------------------


int geometry = 0;
int primnum  = @primnum;

float offset = @Time;
float start = (0.0 + offset) %1;
float end   = (0.1 + offset) %1;


geo_carve_line (geometry, primnum, start, end);


--void geo_carve_line (int geometry, primnum; float start, end)
{

    vector getlinepos(int primnum; float u) {
        vector pos = primuv(0, "P", primnum, set(u,0,0));
        return pos;
    }
    int    createpoint(int primnum; vector pos) {
        int ptnum = addpoint(primnum, pos);
        int vertex = addvertex(0, primnum, ptnum);
        return vertex;
    }

    int oldprim  = primnum;
    int closed   = primintrinsic(geometry, "closed", oldprim);
    int segments = primvertexcount(geometry, oldprim) - 1 + closed;

    //---------------------------
    //---------------------------

    if (start==end){
        //nothing
    }

    //---------------------------
    //---------------------------

    if (start<end){
    
        int newprim = addprim(geometry, "polyline");
        setprimattrib(0, "newprim", newprim, primnum, "set");        

        //new point at start
        createpoint(newprim, getlinepos(oldprim, start));
                
        //points from prim
        int startvert, endvert;

        startvert  = 1 + floor(start * segments);
        endvert    = 1 + floor(end * segments);
        endvert    = min(endvert, segments);
        
        for (int i = startvert; i < endvert; i++)
        {
            vector vertpos = vertex(geometry, "P", oldprim, i);
            createpoint(newprim, vertpos);
        }

        //new point at end
        createpoint(newprim, getlinepos(oldprim, end));

    } 

    //---------------------------
    //---------------------------


    if (start>end){



        int newprim_beg = addprim(geometry, "polyline");
        setprimattrib(0, "newprim", newprim_beg, primnum, "set");
        
        //from prim
        int startvert, endvert;
        startvert  = 1 + floor(start * segments);
        endvert    = 1 + floor(end * segments);
        endvert    = min(endvert, segments);
        
        for (int i = 0; i < endvert; i++)
        {
            vector vertpos = vertex(geometry, "P", oldprim, i);
            createpoint(newprim_beg, vertpos);
        }
        
        //new point at end
        createpoint(newprim_beg, getlinepos(oldprim, end));
        
        //new point at start
        int newprim_end = addprim(geometry, "polyline");
        setprimattrib(0, "newprim", newprim_end, primnum, "set");

        createpoint(newprim_end, getlinepos(oldprim, start));
        
        //from prim
        for (int i = startvert; i <= segments; i++)
        {
            vector vertpos;
            if (i==segments && closed)
            {
                // this is special, on closed: last = firt        
                vertpos = vertex(geometry, "P", oldprim, 0);
            } else {
                // usual point
                vertpos = vertex(geometry, "P", oldprim, i);
            }
            createpoint(newprim_end, vertpos);
        }
    }

    //---------------------------
    //---------------------------

    removeprim(geometry, oldprim, 1);

    //return newprim;

}

///------------------------------------------------------------------------------------------------

int geometry = 0;

  vector farthest_point_from = point(1,"P",0);
//vector farthest_point_from = chv("farthest_point_from");

geo_farthest_point_position (geometry, farthest_point_from);

--vector geo_farthest_point_position (int geometry; vector farthest_point_from) //run over detail of input 0
{
    int count = npoints(geometry);
    float maxdist = 0;
    vector eval;

    for (int pt = 0; pt < count; pt++)
    {
        vector sample_pos = point(0,"P",pt);
        float distance = length(sample_pos - farthest_point_from);
        if (distance > maxdist) 
        {
            maxdist = distance;
            eval    = sample_pos;
        }
    }
    return eval;
}

///------------------------------------------------------------------------------------------------

int geometry = 0;

  vector farthest_distance_from = point(1,"P",0);
//vector farthest_distance_from = chv("farthest_distance_from");

geo_farthest_point_distance (geometry, farthest_distance_from);


--vector geo_farthest_point_distance (int geometry; vector from) //pointcloud of input 0
{
    int maxpts = npoints( geometry);
    int handle = pcopen( geometry, "P", from, radius, maxpts);
    float eval = pcfarthest(handle);
    pcclose(handle);
    return eval;
}



///------------------------------------------------------------------------------------------------

// geo can be number or /obj/geo/out
string surface_geo = chs("surface_geo"); // node
int surface_geo    = 0;
vector from        = @P;

vector closest = geo_closest_point_position_input(surface_geo, from);

--vector geo_closest_point_position(string surface_geo; vector from)
{
    vector uv_found ;
    int prim_found ;
    float distance = xyzdist("op:" + surface_geo, from, prim_found, uv_found);
    vector pos_closest = primuv("op:" + surface_geo, "P", prim_found, uv_found);
    return pos_closest;
}

vector geo_closest_point_position(int surface_geo; vector from)
{
    vector uv_found ;
    int prim_found ;
    float distance = xyzdist(surface_geo, from, prim_found, uv_found);
    vector pos_closest = primuv(surface_geo, "P", prim_found, uv_found);
    return pos_closest;
}


///------------------------------------------------------------------------------------------------


int geometry = 0;

vector direction_from = point(1,"P",0);
vector direction_to = point(1,"P",1);

//vector direction_from = chv("direction_from");
//vector direction_to   = chv("direction_to");

vector result_from;
vector result_to;


geo_bounding_vector (geometry, direction_from, direction_to, result_from, result_to);


--void geo_bounding_vector (int geometry; vector direction_from, direction_to, result_from, result_to)
{
    vector u, v, pos, center;
    float distance, mindist, maxdist;
    int count = npoints(geometry);

    u = normalize(direction_to - direction_from);
    mindist = 1e10;
    maxdist = -1e10;

    for (int pt = 0; pt < count; pt++)
    {   
        pos = point(geometry,"P",pt);
        v = pos - direction_from;
        distance = dot(u,v);

        maxdist = max(distance, maxdist);
        mindist = min(distance, mindist);
    }

    v = getbbox_center(geometry) - direction_from;
    center = dot(u,v);

    result_to = (maxdist - center) * u + getbbox_center(geometry) ;
    result_from = (mindist - center) * u + getbbox_center(geometry) ;
}




///------------------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
/////////           vectors           /////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///------------------------------------------------------------------------------------------------

qqxx.rotation // 0 in -360 to 360

--vector vec_len_fit01(vector noise; float xmin, xmax, ymin, ymax, zmin, zmax)
{
    vector eval = noise;

    eval[0] = fit01(eval[0], xmin, xmax);
    eval[1] = fit01(eval[1], ymin, ymax);
    eval[2] = fit01(eval[2], zmin, zmax);

    return eval;
}


///------------------------------------------------------------------------------------------------

float amount = chf("amount"); // 1 in 0 to 1
vec = vec_dir_randomize(vec, amount, seed);

--vector vec_dir_randomize(vector vec; float amount, seed) {

    vector vec_rand;
    float length_orig = length(vec);

    // getting different random value for each axis, scaling to [-1..1] range
    // thanks to Juraj Tomori for this script
    vec_rand.x = rand(seed * 684.49848) * 2 - 1;
    vec_rand.y = rand(seed * 178.46548) * 2 - 1;
    vec_rand.z = rand(seed * 489.49856) * 2 - 1;
    
    vec_rand = lerp(vec, vec_rand, amount);
    vec_rand = normalize(vec_rand) * length_orig;

    return vec_rand;
}

///------------------------------------------------------------------------------------------------


vector pos = @P;
vector noise = curlnoise(pos*scale);
vector quant = {0,0,0};

float amount = chf("amount"); // 1 in 0 to 1


vec = vec_dir_quantize();


--vector vec_dir_quantize(vector orig )
{


    int reference_geo = 1;
    // vec_prim = 0;
    // vec_total = primvertexcount(reference_geo, vec_prim);
    vector quant = {0,0,0};

    int count = 3;

    for (int i = 0; i < count; i++)
    {
        vector quant_dir = normalize(  point(reference_geo,"P",i)  ) ;
        
        float quant_add;
        quant_add = dot (  normalize(orig)  ,  quant_dir  );
        quant_add = rint (quant_add) ;

        quant += quant_add * quant_dir;
    }

    quant = length(orig) * normalize( quant );
    return quant;

}



///------------------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
/////////         intrinsics          /////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///------------------------------------------------------------------------------------------------



vector4 quaternion = @orient;
vector euler = euler_from_quat(quaternion);

--vector euler_from_quat(vector4 orient)
{
    vector  eval;
    vector4 quaternion = orient;
    matrix m = matrix( qconvert( quaternion ) );
    eval = cracktransform(0, 0, 1, {0,0,0}, m);

    return eval;

}

///------------------------------------------------------------------------------------------------

vector z = @N;
vector y = {0,1,0};

@orient = quat_from_zy(z,y);

--vector4 quat_from_zy(vector z,y)
{
    vector4 eval;
    matrix3 m = maketransform(z, y);
    eval = quaternion(m);
    return eval;
}

///------------------------------------------------------------------------------------------------


vector  amount = set(0,0,0);   // rotiation in degrees
vector  pivot  = set(0,0,0);   // pivot position
vector4 orient = set(0,0,0,1); // pivot rotation

matrix xmat = xmat(amount, pivot, orient, "rotate"); // "scale"  "translate"

--matrix xmat(vector amount, pivot; vector4 orient; string trs)
{
    matrix eval;

    vector t = {0,0,0};
    vector r = {0,0,0};
    vector s = {1,1,1};

    vector pr = euler_from_quat(orient);

    if (trs == "translate")    
        t = amount;
    if (trs == "rotate")       
        r = amount;
    if (trs == "scale")        
        s = amount;

    eval = maketransform(0, 0,  t,  r,  s,  pivot, pr);

    return eval;
}

///------------------------------------------------------------------------------------------------


intri_xmat(@ptnum, xmat);

--void intri_xmat(int primnum; matrix xmat)
{
    matrix3 transform = primintrinsic(0, "transform", primnum);
    transform *= matrix3 (xmat);
    setprimintrinsic(0,"transform", primnum, transform);
}

///------------------------------------------------------------------------------------------------


// packed disk primitive
setprimintrinsic(0, "unexpandedfilename", @primnum, s@path);

// pecked disk sequence (mantra does motion blur on it)
setprimintrinsic(0, "index", @primnum, f@seqnum);
setprimintrinsic(0, "wrap",  @primnum, "mirror"); // "clamp", "cycle", "mirror" or "strict"

// alembic
setprimintrinsic(0, "abcframe", @primnum, f@time);

// i didn't define any function for this

--dontinc intri_geo()


///------------------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
/////////            time             /////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///------------------------------------------------------------------------------------------------


float current    = @Frame;
float zero_at    = 0;
float seq_length = 1;       // 1 to get dimension 01
float speed      = 1;       // -1 to before
string type      = "once";  // loop, ping

f@test = time_sequence(current, zero_at, seq_length, speed, type);

--float time_sequence(float current, zero_at, seq_length, speed; string type)
{

    float eval, seq_length_retimed, relative_range;

    seq_length_retimed = seq_length / speed;
    relative_range = (current - zero_at) / seq_length_retimed;

    if (type == "once")
    {
        relative_range = clamp(relative_range, 0, 1);
        eval = relative_range * seq_length;
    }

    if (type == "loop")
    {
        relative_range = relative_range % 1;
        eval = relative_range * seq_length;
    }

    if (type == "ping")
    {
        relative_range = 1 - abs (relative_range % 2 - 1);
        eval = relative_range * seq_length;
    }

    return eval;
}

///------------------------------------------------------------------------------------------------

//-----
float value_at_snap = chf("value_at_snap");    // 0.5 in 0.0 to 1.0
//-----
int frame_snap      = chi("frame_snap");       // 100 in 0 to 500
int smooth_frames   = chi("smooth_frames");    // 0 in -100 to 100
//# negative smooth_frames means before snap
//-----
float speed_before  = chf("speed_before");     // 0 in 0.0 to 0.1
float speed_after   = chf("speed_after");      // 0 in 0.0 to 0.1

int frame_current   = int (rint(@Frame));

float value = time_snap(frame_current, frame_snap, smooth_frames, value_at_snap, speed_before, speed_after);

--float time_snap(int frame_current, frame_snap, smooth_frames; float value_at_snap, speed_before, speed_after)

{
    int frame_0 = min(frame_snap,frame_snap + smooth_frames);
    int frame_1 = max(frame_snap,frame_snap + smooth_frames);


    // distance linear after
    int     frames_lin_after  = max(0,  frame_current-frame_1  );
    float distance_lin_after  = frames_lin_after * speed_after;


    // distance linear before
    int     frames_lin_before = min(0,  frame_current-frame_0  );
    float distance_lin_before = frames_lin_before * speed_before;


    // distance smooth
    int range_start = 0;
    int range_end   = 0;
    float sign      = 0;

    if (frame_current > frame_snap && smooth_frames > 0)
    {
        range_start = frame_snap;
        range_end   = min(frame_current, frame_1);
        sign        = 1.0;
    }

    if (frame_current < frame_snap && smooth_frames < 0)
    {
        range_start = max(frame_current, frame_0);
        range_end   = frame_snap;
        sign        = -1.0;
    }

    float distance_smooth = 0;

    for (int f_in = range_start; f_in < range_end ; f_in++)
    {
            float speed     = smooth(frame_0, frame_1, f_in);
            speed           = fit01(speed,speed_before,speed_after);
            distance_smooth += sign * speed;
    }

    float distance;

    distance = value_at_snap;
    distance += distance_lin_before;
    distance += distance_lin_after;
    distance += distance_smooth;

    return distance;
}


///------------------------------------------------------------------------------------------------

//-----
int snapframe_0     = chi("snapframe_0");       // 100 in 0 to 500
int snapframe_1     = chi("snapframe_1");       // 100 in 0 to 500
//-----
int frames_smooth_0 = chi("frames_smooth_0");    //  10 in 0 to 100
int frames_smooth_1 = chi("frames_smooth_1");    // -10 in -100 to 0
//# frames_smooth_1 has to be negative (before snapframe_1)

//-----
float value_0       = chf("value_0");     // 0 in 0.0 to 1
float value_1       = chf("value_1");     // 0 in 0.0 to 1

int frame_current   = int (rint(@Frame));

float value = time_twosnap(frame_current, snapframe_0, snapframe_1, frames_smooth_0, frames_smooth_1, value_0, value_1);


--float time_twosnap(int frame_current, snapframe_0, snapframe_1, frames_smooth_0, frames_smooth_1; float value_0, value_1)

{
    int cur    = frame_current;

    // check for overlaps
    int snap_0 = min(snapframe_0,snapframe_1);
    int snap_1 = max(snapframe_0,snapframe_1);

    int range_total = snap_1 - snap_0;
    int range_lin   = max (0, range_total - frames_smooth_0 + frames_smooth_1);
    int range_0     = max (0, range_total - range_lin   + frames_smooth_1);
    int range_1     = max (0, range_total - range_lin   - range_0);

    // keyframes (range breaks)
    int key_0 = snap_0;
    int key_1 = snap_0 + range_0;
    int key_2 = snap_1 - range_1;
    int key_3 = snap_1;

    // speed
    float speed_normalized = float(range_0)/2 + float(range_1)/2 + float(range_lin);
    float speed_mult       = (value_1 - value_0)  /  speed_normalized;
    float speed;

    float value = value_0;
    

    // distance in range 0
    if(range_0 > 1)
    {
        for (int f_in = key_0; f_in < min(key_1,cur) ; f_in++)
        {
            speed  = speed_mult * smooth(key_0, key_1 - 1, f_in);
            value += speed;
        }
    }

    // distance in range linear
    if(range_lin) 
    {
        for (int f_in = key_1; f_in < min(key_2,cur) ; f_in++)
        {
            speed  = speed_mult;
            value += speed;
        }
    }

    // distance in range 1
    if(range_1 > 1) 
    {
        for (int f_in = key_2; f_in < min(key_3,cur) ; f_in++)
        {
            speed  = speed_mult * (   1 - smooth(key_2, key_3 - 1, f_in)   );
            value += speed;
        }
    }

    return value;
    //return float(range_lin);
}







///------------------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
/////////            mat              /////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///------------------------------------------------------------------------------------------------



// convention:
// ............/name_mov/name_mov_index.ext
// $HIP/img/dir/name_000/name_000_00000.png

string firstfile = chs("firstfile"); // file 
int mov          = 0;
int index        = 0;

override_value = file_mov_index(firstfile, mov, index);

--string file_mov_index(string firstfile; int mov, index)
{

    string split[] = split(firstfile,"/_.");
    int split_len  = len(split);
    //[ D:, bond, "5 houdini", img, dir, name, 000, name, 000, 00000, png ]

    int file_name_len  = len( split[ split_len -4 ] );
    int file_mov_len   = len( split[ split_len -3 ] );
    int file_index_len = len( split[ split_len -2 ] );
    int file_ext_len   = len( split[ split_len -1 ] );

    int afterpath_len  = file_ext_len + 1 + file_index_len + 1 + 2*file_mov_len + 2 + 1 + 2*file_name_len;

    string file_path  = slice(firstfile,0,-afterpath_len);
    string file_name  = split[split_len - 4];
    string file_type  = split[split_len - 1];

    string file_mov   = padzero(file_mov_len, mov);
    string file_index = padzero(file_index_len, index);

    string path;

    path  = file_path;
    path += file_name + "_";
    path += file_mov  + "/";
    path += file_name + "_";
    path += file_mov  + "_";
    path += file_index+ ".";
    path += file_type;

    return path;
}


///------------------------------------------------------------------------------------------------

// convention:
// ............/name_index.ext
// $HIP/img/dir/name_00000.png


string firstfile = chs("firstfile"); // file 
int index        = 0;

override_value = file_index(firstfile, index);

--string file_index(string firstfile; int index)
{

    string split[] = split(firstfile,"/_.");
    int split_len  = len(split);
    //[ D:, bond, "5 houdini", img, "seq timecode", timecode, 00001, jpg ]


    int file_name_len  = len( split[ split_len -3 ] );
    int file_index_len = len( split[ split_len -2 ] );
    int file_ext_len   = len( split[ split_len -1 ] );

    int afterpath_len  = file_ext_len + 1 + file_index_len + 1 + file_name_len;

    string file_path  = slice(firstfile,0,-afterpath_len);
    string file_name  = split[split_len - 3];
    string file_type  = split[split_len - 1];

    string file_index = padzero(file_index_len, index);

    string path;

    path  = file_path;
    path += file_name + "_";
    path += file_index+ ".";
    path += file_type;

    return path;
}


///------------------------------------------------------------------------------------------------



// ogl_opacitymap       RS
// basecolor_texture    MANTRA

string override_name      = chs("override_name");
string override_value     = chs("override_value"); 
int    override_is_string = chi("override_is_string"); //toggle

mat_over(s@material_override , override_name, override_value , override_is_string);

--void mat_over(string actual, override_name, override_value; int override_is_string)
{
    string contents, add, value;
    value = override_value;
    contents = slice(actual,1,-1); // remove { }
    if (override_is_string) value = "'" + value + "'";
    add = "'" + override_name + "':" + value;
    actual = "{" + contents + add + ",}";
}

///------------------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
/////////            color            /////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///------------------------------------------------------------------------------------------------


--void col_hue(vector color; int seed; float spread)
{

}


///------------------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
/////////     noise vec blend         /////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///------------------------------------------------------------------------------------------------

////////////////
// put this in a node
// detail wrangle

f@amp   = chf("amplitude");      // 3 in 0 to 5
//---
f@f     = chf("frequency");      // 1 in 0 to 10
f@fx    = chf("frequency_x");    // 1 in 0 to 10
f@fy    = chf("frequency_y");    // 1 in 0 to 10
f@fz    = chf("frequency_z");    // 1 in 0 to 10
//---
f@s     = chf("speed");          // 1 in 0 to 10
f@sx    = chf("speed_x");        // 1 in 0 to 1
f@sy    = chf("speed_y");        // 1 in 0 to 1
f@sz    = chf("speed_z");        // 1 in 0 to 1
//---
i@turb  = chi("turbulence");     // 1    in 0 to 5
f@rough = chf("roughness");      // 0.5  in 0 to 1
f@atten = chf("attenuation");    // 1    in 0 to 1

f@ox = 1.23;
f@oy = 2.34;
f@oz = 3.45;
f@time = @Time;

/////////////////

vector pos           = @P;
string node_absolute = chs("node_absolute"); // node
vector noise         = noise_vref (pos, node_absolute);

@P  = @P + noise;

--vector noise_vref (vector p; string operator)
{
    float px = p[0];
    float py = p[1];
    float pz = p[2];

    float amp   = detail("op:" + operator , "amp" );
    float f     = detail("op:" + operator , "f" );
    float fx    = detail("op:" + operator , "fx" );
    float fy    = detail("op:" + operator , "fy" );
    float fz    = detail("op:" + operator , "fz" );
    float s     = detail("op:" + operator , "s" );
    float sx    = detail("op:" + operator , "sx" );
    float sy    = detail("op:" + operator , "sy" );
    float sz    = detail("op:" + operator , "sz" );
    int turb    = detail("op:" + operator , "turb" );
    float rough = detail("op:" + operator , "rough" );
    float atten = detail("op:" + operator , "atten" );
    float ox    = detail("op:" + operator , "ox" );
    float oy    = detail("op:" + operator , "oy" );
    float oz    = detail("op:" + operator , "oz" );
    float time  = detail("op:" + operator , "time" );

    float x = px * f * fx - ox + s * sx * time;
    float y = py * f * fy - oy + s * sy * time;
    float z = pz * f * fz - oz + s * sz * time;

    vector pos = set(x,y,z);
    vector noise;

    noise = onoise(pos, turb, rough, atten);
    noise = noise * amp;

    noise[0] = smooth(-1,1,noise[0]);
    noise[1] = smooth(-1,1,noise[1]);
    noise[2] = smooth(-1,1,noise[2]);

    return noise;

}

///------------------------------------------------------------------------------------------------

// noise UI

//---
float      amp = chf("amplitude");      // 3 in 0 to 5
//---
float        f = chf("frequency");      // 1 in 0 to 10
float       fx = chf("frequency_x");    // 1 in 0 to 10
float       fy = chf("frequency_y");    // 1 in 0 to 10
float       fz = chf("frequency_z");    // 1 in 0 to 10
//---
int       turb = chi("turbulence");     // 1   in 0 to 5
float    rough = chf("roughness");      // 0.5 in 0 to 1
float    atten = chf("attenuation");    // 1   in 0 to 1


// noise FUNCTION

float       ox = 1.23;
float       oy = 2.34;
float       oz = 3.45;
float       px = @rest.x; //@uv.x  @P.x
float       py = @rest.y; //@uv.y  @P.y
float       pz = @rest.z; //@uv.z  @P.z

vector   noise = noise_vstat ( px, py, pz , f, fx, fy, fz, ox, oy, oz, turb, rough, atten, amp );

@P = @P + noise;
//@P.x += getcomp(noise,0);

--vector noise_vstat (float px, py, pz , f, fx, fy, fz, ox, oy, oz; int turb; float rough, atten, amp )
{

    float x = px * f * fx - ox;
    float y = py * f * fy - oy;
    float z = pz * f * fz - oz;

    vector pos = set(x,y,z);
    vector noise;

    noise = onoise(pos, turb, rough, atten);
    noise = noise * amp;

    noise[0] = smooth(-1,1,noise[0]);
    noise[1] = smooth(-1,1,noise[1]);
    noise[2] = smooth(-1,1,noise[2]);

    return noise;

}


///------------------------------------------------------------------------------------------------


// noise UI

//---
float      amp = chf("amplitude");      // 3 in 0 to 5
//---
float        f = chf("frequency");      // 1 in 0 to 10
float       fx = chf("frequency_x");    // 1 in 0 to 10
float       fy = chf("frequency_y");    // 1 in 0 to 10
float       fz = chf("frequency_z");    // 1 in 0 to 10
//---
float        s = chf("speed");          // 1 in 0 to 10
float       sx = chf("speed_x");        // 1 in 0 to 1
float       sy = chf("speed_y");        // 1 in 0 to 1
float       sz = chf("speed_z");        // 1 in 0 to 1
//----
int       turb = chi("turbulence");     // 1    in 0 to 5
float    rough = chf("roughness");      // 0.5  in 0 to 1
float    atten = chf("attenuation");    // 1    in 0 to 1


// noise FUNCTION

float       ox = 1.23;
float       oy = 2.34;
float       oz = 3.45;
float     time = @Time;
float       px = @rest.x; //@uv.x  @P.x
float       py = @rest.y; //@uv.y  @P.y
float       pz = @rest.z; //@uv.z  @P.z

vector   noise = noise_vanim ( px, py, pz , f, fx, fy, fz, s, sx, sy, sz, ox, oy, oz, time, turb, rough, atten, amp );

@P = @P + noise;
//@P.x += getcomp(noise,0);

--vector noise_vanim (float px, py, pz , f, fx, fy, fz, s, sx, sy, sz, ox, oy, oz, time; int turb; float rough, atten, amp )
{

    float x = px * f * fx - ox + s * sx * time;
    float y = py * f * fy - oy + s * sy * time;
    float z = pz * f * fz - oz + s * sz * time;

    vector pos = set(x,y,z);
    vector noise;

    noise = onoise(pos, turb, rough, atten);
    noise = noise * amp;

    noise[0] = smooth(-1,1,noise[0]);
    noise[1] = smooth(-1,1,noise[1]);
    noise[2] = smooth(-1,1,noise[2]);

    return noise;

}

///------------------------------------------------------------------------------------------------


// noise UI

//---
float      amp = chf("amplitude");      // 3 in 0 to 5
float        f = chf("frequency");      // 1 in 0 to 10
//---
int       turb = chi("turbulence");     // 1    in 0 to 5
float    rough = chf("roughness");      // 0.5  in 0 to 1
float    atten = chf("attenuation");    // 1    in 0 to 1


// noise FUNCTION

float   offset = 1.23;
float      pos = dimension;

float    noise = noise_fstat ( pos, f, offset, turb, rough, atten, amp );

--float noise_fstat ( float pos, f, offset; int turb; float rough, atten, amp )
{

    float sample = pos * f - offset;
    float noise;

    noise = onoise(sample, turb, rough, atten);
    noise = noise * amp;

    noise = smooth(-1,1,noise);

    return noise;

}

///------------------------------------------------------------------------------------------------


// noise UI

//---
float      amp = chf("amplitude");      // 3 in 0 to 5
float        f = chf("frequency");      // 1 in 0 to 10
//---
float       sx = chf("speed_along");    // 1 in 0 to 10
float       sy = chf("speed_cross");    // 1 in 0 to 10
//----
int       turb = chi("turbulence");     // 1    in 0 to 5
float    rough = chf("roughness");      // 0.5  in 0 to 1
float    atten = chf("attenuation");    // 1    in 0 to 1

// noise FUNCTION

float       ox = 1.23;
float       oy = 2.34;
float     time = @Time;
float       px = @uv.x;   //
float       py = @rest.y; //@uv.y  @P.y

float    noise = noise_fanim ( px, py, f, sx, sy, ox, oy, time, turb, rough, atten, amp );

--float noise_fanim ( float px, py, f, sx, sy, ox, oy, time; int turb; float rough, atten, amp )
{

    float x = px * f - ox + sx * time;
    float y = py * f - oy + sy * time;
    float z = 12.3456789;

    vector pos = set(x,y,z);
    vector noise;

    noise = onoise(pos, turb, rough, atten);
    noise = noise * amp;

    float noise_x = getcomp(noise, 0);
    noise_x = smooth(-1,1,noise_x);

    return noise_x;

}

///------------------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
/////////   just qq  / dont include   /////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///------------------------------------------------------------------------------------------------

for (int i = 0; i < count; i++)
{
    
}

--dontinc for()

///------------------------------------------------------------------------------------------------

if (  )
{
    
}
--dontinc if()

///------------------------------------------------------------------------------------------------

int pts[] = neighbours(0, @ptnum);
foreach (float read; array[])
foreach (int nb_ptnum; pts) {
{
    
}
--dontinc feach()

///------------------------------------------------------------------------------------------------

point(0, "P", @ptnum);
--dontinc pt()

///------------------------------------------------------------------------------------------------

detail(0, "name", 0);
--dontinc det()


///------------------------------------------------------------------------------------------------

@P = primuv(0, "P", @primnum, set(u,0,0));
--dontinc primuv()

///------------------------------------------------------------------------------------------------

prim(0, "name", primnum);
--dontinc prim()

///------------------------------------------------------------------------------------------------

setpointattrib(0, "name", @ptnum, value, "set");
--dontinc setpt()

///------------------------------------------------------------------------------------------------

setprimattrib(0, "name", @primnum, value, "set");
--dontinc setprim()

///------------------------------------------------------------------------------------------------

setdetailattrib(0, "name", value, "set");
--dontinc setdet()

///------------------------------------------------------------------------------------------------

vector center   = {0,0,1};
float  maxangle = radians( chf("maxangle") ); // 45 in 0 to 90
v@N             = sample_direction_cone( center, maxangle, rand(@ptnum) );

--dontinc randir()

///------------------------------------------------------------------------------------------------

float angle = radians( 90 );
vector axis = {0,1,0};
matrix3 m   = ident();
rotate(m, angle, axis);

--dontinc rotmat()

///------------------------------------------------------------------------------------------------

// consider to run over detail

int ptnum   = addpoint (0, @pos );
int primnum = addprim (0, "poly" ); //poly, polyline
int vertnum = addvertex (0, primnum, ptnum);
setpointattrib(0, "name", ptnum, value, "set");

--dontinc addpt()


///------------------------------------------------------------------------------------------------

// consider to run over detail

int ptnum0   = addpoint (0, @pos );
int ptnum1   = addpoint (0, @pos );

int primnum = addprim (0, "poly" ); //poly, polyline

int vertnum0 = addvertex (0, primnum, ptnum0);
int vertnum1 = addvertex (0, primnum, ptnum1);

setpointattrib(0, "name", ptnum0, value, "set");
setpointattrib(0, "name", ptnum1, value, "set");

--dontinc addprim()

///------------------------------------------------------------------------------------------------

float x = getcomp( relbbox(0,@P) , 0 );

--dontinc rbx()

///------------------------------------------------------------------------------------------------

float maxdist = chf("maxdist"); // 1 in 0 to 2
int maxpts    = chf("maxpts"); // 1 in 1 to 100
array[]       = nearpoints(0, vector pt, maxdist, int maxpts);

--dontinc nearpts()

///------------------------------------------------------------------------------------------------

removepoint(0, @ptnum);
--dontinc rempt()

///------------------------------------------------------------------------------------------------

removeprim(0, @primnum, andpoints);
--dontinc remprim()

///------------------------------------------------------------------------------------------------

volumesample(0, primnum, pos);
--dontinc volsamp()

///------------------------------------------------------------------------------------------------

xyzdist(0, pos, int &prim, vector &uv, float maxdist);
--dontinc xyzdist()

///------------------------------------------------------------------------------------------------

vector value;
vector nmax = chf("new_max"); // 0.5 in 0 to 10; 
vector nmin = -nmax;
value = fit01(value, nmin, nmax);

--dontinc fit01vs()

///------------------------------------------------------------------------------------------------

float value;
float nmax = chf("new_max"); //  0.5 in 0 to 10
float nmin = -nmax; 
value = fit01(value, nmin, nmax);

--dontinc fit01s()

///------------------------------------------------------------------------------------------------

float value;
float nmin = chf("new_min"); // -1 in -1 to 1
float nmax = chf("new_max"); //  1 in -1 to 1
value = fit01(value, nmin, nmax);

--dontinc fit01()

///------------------------------------------------------------------------------------------------

float value;
float omin = chf("old_min"); // 0 in 0 to 1
float omax = chf("old_max"); // 1 in 0 to 1
float nmin = chf("new_min"); // 0 in 0 to 1
float nmax = chf("new_max"); // 1 in 0 to 1
value = fit(value, omin, omax, nmin, nmax);

--dontinc fit()

///------------------------------------------------------------------------------------------------

float value;
float omin    = chf("old_min"); // 0 in 0 to 1
float omax    = chf("old_max"); // 1 in 0 to 1
float rolloff = chf("rolloff"); // 1 in 0 to 1
value = smooth(omin, omax, value, float rolloff); 

--dontinc smooth()

///------------------------------------------------------------------------------------------------

vector from;
vector to;
float amount = 0;
vector result = lerp(from, to, amount);

--dontinc lerp()

///------------------------------------------------------------------------------------------------

vector from;
vector to;
vector up;
matrix3 mrot = lookat(from, to, up);

--dontinc lookat()

///------------------------------------------------------------------------------------------------

float radius = chf("radius"); // 1 in 0 to 2
int maxpts = chi("maxpts"); // 1 in 1 to 100
int handle = pcopen(0, "P", @P, radius, maxpts);
while(pciterate(handle))
{
    float imp_pressure = pcfilter(handle, "pressure");

    pcimport(handle, "Cd", col);
    pcimport(handle, "point.distance", dist);
    pcimport(handle, "point.number", num);

    eval += imp_pressure*(1-dist/radius);
    pt_count++;
}
eval = eval/pt_count;
pcclose(handle);


--dontinc pc()

///------------------------------------------------------------------------------------------------

float radius = chf("radius"); // 1 in 0 to 2
int maxpts   = chf("maxpts"); // 1 in 1 to 100
int handle   = pcopen(0, "P", @P, radius, maxpts);
vector value = pcfilter(handle, "P");

--dontinc pcfilter()

///------------------------------------------------------------------------------------------------

printf("OUT=%f; ", out); //  %s string,   %i integer
printf("\n");

--dontinc printf()


///------------------------------------------------------------------------------------------------

@N  = {0,0,1};
@up = {0,1,0};
--dontinc nup()

///------------------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
/////////           include           /////////////////////////////////////////////////////////////
/////////                             /////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////
///------------------------------------------------------------------------------------------------

#include "qq.vfl"
--dontinc inc()

///------------------------------------------------------------------------------------------------