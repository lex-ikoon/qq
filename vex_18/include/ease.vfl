#include <math.h>
#include <aevex.vfl>

// Penner's Equations
//------------------------------------------------------------------
float function_PennerEaseInBack (float x) {
  string functionName = "Penner's Ease-In Back";

  float s = 1.70158;
  float y = x*x*((s+1.0)*x - s);
  return y;
}

//------------------------------------------------------------------
float function_PennerEaseOutBack (float x) {
  string functionName = "Penner's Ease-Out Back";

  float s = 1.70158;
  float x2 = x-1.0;
  float y = (x2*x2*((s+1.0)*x2 + s) + 1.0);
  return y;
}

//------------------------------------------------------------------
float function_PennerEaseInOutBack (float x) {
  string functionName = "Penner's EaseInOut Back";

  float s = 1.70158 * 1.525;
  float x2 = x / 0.5;

  float y = 0; 
  if (x2 < 1) {
    y = 1.0/2.0* (x2*x2*((s+1.0)*x2 - s));
  } 
  else {
    x2 -= 2.0;
    y = 1.0/2.0* (x2*x2*((s+1.0)*x2 + s) + 2.0);
  } 
  return y;
}


//------------------------------------------------------------------
float function_BrycePolynomial (float x; int n){
  string functionName = "Bryce's Cubic";
  
  float xnm1 = pow (x, n-1); 
  float xn = xnm1 * x; 
  
  return n*xnm1 - (n-1)*xn; 
}

//------------------------------------------------------------------
float function_PennerEaseInQuadratic (float x) {
  string functionName = "Penner's EaseIn Quadratic";
  return x*x;
}
//------------------------------------------------------------------
float function_PennerEaseOutQuadratic (float x) {
  string functionName = "Penner's EaseOut Quadratic";
  return -1.0 *(x)*(x-2);
}
//------------------------------------------------------------------
float function_PennerEaseInOutQuadratic (float x) {
  string functionName = "Penner's EaseInOut Quadratic";
  if ((x/=1.f/2) < 1) return 1.f/2*x*x;
  return -1.f/2 * ((--x)*(x-2) - 1);
}

//------------------------------------------------------------------
float function_PennerEaseInCubic (float x) {
  string functionName = "Penner's EaseIn Cubic";
  return x*x*x;
}

//------------------------------------------------------------------
float function_PennerEaseOutCubic (float x) {
  string functionName = "Penner's EaseOut Cubic";
  float x2 = x-1.0;
  return (x2*x2*x2 + 1);
}


//------------------------------------------------------------------
float function_PennerEaseInOutCubic (float x) {
  string functionName = "Penner's EaseInOut Cubic";
  
  float x2 = x * 2.0; 
  float y = 0; 

  if (x2 < 1) {
    y = 0.5 * x2*x2*x2;
  } 
  else {
    x2 -= 2.0;
    y = 0.5 * (x2*x2*x2 + 2.0);
  }
  return y;
}


//------------------------------------------------------------------
float function_PennerEaseInQuartic (float x) {
  string functionName = "Penner's EaseIn Quartic";
  return x*x*x*x;
}
//------------------------------------------------------------------
float function_PennerEaseOutQuartic (float x) {
  string functionName = "Penner's EaseOut Quartic";
  float x2 = x-1;
  return -1.0 * (x2*x2*x2*x2 - 1.0);
}

//------------------------------------------------------------------
float function_PennerEaseInOutQuartic (float x) {
  string functionName = "Penner's EaseInOut Quartic";
  float x2 = x/0.5;
  if (x2 < 1) return 1.0/2.0*x2*x2*x2*x2;
  float x3 = (x-2.0);
  return -1.0/2.0 * (x3*x3*x3*x3 - 2.0);
}

//------------------------------------------------------------------
float function_PennerEaseInQuintic (float x) {
  string functionName = "Penner's EaseIn Quintic";
  return x*x*x*x*x;
}
//------------------------------------------------------------------
float function_PennerEaseOutQuintic (float x) {
  string functionName = "Penner's EaseOut Quintic";
  float x2 = x-1;
  return (x2*x2*x2*x2*x2 + 1.0);
}

//------------------------------------------------------------------
float function_PennerEaseInOutQuintic (float x) {
  string functionName = "Penner's EaseInOut Quintic";
  float x2 = x/0.5;  
  if (x2 < 1) return 1.0/2*x2*x2*x2*x2*x2;
  float x3 = (x-2.0); 
  return 1.0/2*(x3*x3*x3*x3*x3 + 2);
}

//------------------------------------------------------------------
float function_PennerEaseInSine (float x) {
  string functionName = "Penner's EaseIn Sine";
  return -1.0 * cos(x * (M_PI/2)) + 1;
}

//------------------------------------------------------------------
float function_PennerEaseOutSine(float x) {
  string functionName = "Penner's EaseOut Sine";
  return sin(x * (M_PI/2));
}

//------------------------------------------------------------------
float function_PennerEaseInOutSine(float x) {
  string functionName = "Penner's EaseInOut Sine";
  return -0.5 * (cos(M_PI*x) - 1);
}




//------------------------------------------------------------------
float function_PennerEaseInExpo(float x) {
  string functionName = "Penner's EaseIn Exponential";
  return (x==0) ? 0 : pow(2, 10 * (x - 1));
}

//------------------------------------------------------------------
float function_PennerEaseOutExpo(float x) {
  string functionName = "Penner's EaseOut Exponential";
  return (x==1) ? 1 : (-pow(2, -10 * x) + 1);
}

//------------------------------------------------------------------
float function_PennerEaseInOutExpo(float x) {
  string functionName = "Penner's EaseInOut Exponential";
  if (x==0) return 0.0;
  if (x==1) return 1.0;
  float x2 = x/0.5;
  if (x2 < 1) return 1.0/2 * pow(2, 10 * (x2 - 1));
  // return 1.0/2 * (-pow(2, -10 * --x) + 2);
  return 1.0/2 * (-pow(2, -10 * (x2-1)) + 2);
}

//------------------------------------------------------------------
float function_PennerEaseInElastic (float x) {
  string functionName = "Penner's EaseIn Elastic";

  if (x==0) return 0.0; 
  if (x==1) return 1.0;
  float p = 0.3;

  float s=p/4;
  float postFix = pow(2, 10.0 * (x-1)); // this is a fix, again, with post-increment operators

  return -(postFix * sin((x-s)*(2*M_PI)/p ));
}

//------------------------------------------------------------------
float function_PennerEaseOutElastic(float x) {
  string functionName = "Penner's EaseOut Elastic";
  
  if (x==0) return 0.0; 
  if (x==1) return 1.0;
  float p = 0.3;
  float s = p/4;

  return (pow(2, -10*x) * sin( (x-s)*(2*M_PI)/p ) + 1);
}

//------------------------------------------------------------------
float function_PennerEaseInOutElastic (float x) {
  string functionName = "Penner's EaseInOut Elastic";

  if(x < 0.5){
		return 0.5 * sin(13 * 2*M_PI * (2 * x)) * pow(2, 10 * ((2 * x) - 1));
	}
	else {
		return 0.5 * (sin(-13 * 2*M_PI * ((2 * x - 1) + 1)) * pow(2, -10 * (2 * x - 1)) + 2);
	}

  // Appears to be broken?
  // if (x==0) return 0; 
  // float x2 = x/0.5;
  // if (x2==2) return 1;
  // float p=(0.3*1.5);
  // float a=1;
  // float s=p/4;

  // if (x < 1) {
  //   float postFix = pow(2, 10*(x2-1)); // postIncrement is evil
  //   return -0.5*(postFix* sin( (x2-s)*(2*M_PI)/p ));
  // } 
  // float postFix = pow(2, -10*(x2-1)); // postIncrement is evil
  // return postFix * sin( (x2-s)*(2*M_PI)/p )*.5 + 1;
}

//------------------------------------------------------------------
float function_PennerEaseOutBounce (float x) {
  string functionName = "Penner's EaseOut Bounce";
  float x2 = x;
  if ((x) < (1.0 / 2.75)) {
    return (7.5625 * x2*x2);
  } 
  else if (x < (2.0/2.75)) {
    float postFix = x2-=(1.5/2.75);
    return (7.5625*(postFix)*x2 + 0.75);
  } 
  else if (x < (2.5/2.75)) {
    float postFix = x2-=(2.25/2.75);
    return (7.5625*(postFix)*x2 + 0.9375);
  } 
  else {
    float postFix = x2-=(2.625/2.75);
    return (7.5625*(postFix)*x2 + 0.984375);
  }
}

//------------------------------------------------------------------
float function_PennerEaseInBounce (float x) {
  string functionName = "Penner's EaseIn Bounce";
  return (1.0 - function_PennerEaseOutBounce(1.0-x));
}

//------------------------------------------------------------------
float function_PennerEaseInOutBounce(float x) {
  string functionName = "Penner's EaseInOut Bounce";
  if (x < 0.5) {
    return function_PennerEaseInBounce(x*2) * .5;
  } 
  else {
    return function_PennerEaseOutBounce(x*2-1) * .5 + .5;
  }
}

//------------------------------------------------------------------
float function_Staircase (float x; int n) {
  string functionName = "Staircase";
  float y = floor(x*n) / float(n-1);
  return y;
}

//------------------------------------------------------------------
float function_ExponentialSmoothedStaircase (float x, a; int n) {
  string functionName = "Smoothed Exponential Staircase";
  // See http://web.mit.edu/fnl/volume/204/winston.html
  
  float fa = pow(fit(a, 0,1, 5,30), 2);
  float y = 0; 
  for (int i=0; i<n; i++){
    y += (1.0/(n-1.0))/ (1.0 + exp(fa*(((i+1.0)/n) - x)));
  }
  y = clamp(y, 0,1); 
  return y;
}


//------------------------------------------------------------------
float function_Gompertz (float x, a) {
  // http://en.wikipedia.org/wiki/Gompertz_curve
  string functionName = "Gompertz Function";
 
  float min_param_a = 0.0 + M_E;
  float aa = max(a, min_param_a); 

  float b = -8.0;
  float c = 0 - aa*16.0;
  float y = exp( b * exp(c * x));

  float maxVal = exp(b * exp(c));
  float minVal = exp(b );
  y = fit(y, minVal, maxVal, 0, 1); 

  return y ;
}

// Generalized fit
float function_GeneralizedLinearfit (float x, a, b, c, d) {
  string functionName = "Generalized Linear fit";
  
  float y = 0;
  if (a < c) {
    if (x <= a) {
      y = b;
    } 
    else if (x >= c) {
      y = d;
    } 
    else {
      y = fit(x, a, c, b, d);
    }
  } 
  else {
    if (x <= c) {
      y = d;
    } 
    else if (x >= a) {
      y = b;
    } 
    else {
      y = fit(x, c, a, d, b);
    }
  }
  return y;
}

// Double-(Odd) Polynomial Seat
//------------------------------------------------------------------
float function_DoubleOddPolynomialOgee (float x, a, b; int n) {
  string functionName = "Double Odd-Polynomial Ogee";

  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  float min_param_b = 0.0;
  float max_param_b = 1.0;

  float aa = clamp(a, min_param_a, max_param_a); 
  float bb = clamp(b, min_param_b, max_param_b); 
  int p = 2*n + 1;
  float y = 0;
  if (x <= aa) {
    y = bb - bb*pow(1-x/aa, p);
  } 
  else {
    y = bb + (1-bb)*pow((x-aa)/(1-aa), p);
  }
  return y;
}

// Double-Linear Interpolator
//------------------------------------------------------------------
float function_DoubleLinear (float x, a, b) {
  string functionName = "Double-Linear";

  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  float min_param_b = 0.0;
  float max_param_b = 1.0;
  float aa = clamp(a, min_param_a, max_param_a); 
  float bb = clamp(b, min_param_b, max_param_b); 

  float y = 0;
  if (x<=aa) {
    y = (bb/a) * x;
  } 
  else {
    y = bb + ((1-bb)/(1-aa))*(x-aa);
  }
  return y;
}

//------------------------------------------------------------------
// Generalized fit
float function_TripleLinear (float x, a, b, c, d) {
  string functionName = "Triple Linear";

  float y = 0;
  if (a < c) {
    if (x <= a) {
      y = fit(x, 0, a, 0, b);
    } 
    else if (x >= c) {
      y = fit(x, c, 1, d, 1);
    } 
    else {
      y = fit(x, a, c, b, d);
    }
  } 
  else {
    if (x <= c) {
      y = fit(x, 0, c, 0, d);
    } 
    else if (x >= a) {
      y = fit(x, a, 1, b, 1);
    } 
    else {
      y = fit(x, c, a, d, b);
    }
  }
  return y;
}

//------------------------------------------------------------------
float function_VariableStaircase (float x, a; int n) {
  string functionName = "Variable Staircase";

  float aa = (a - 0.5);
  if (aa == 0) {
    return x;
  }

  float x0 = (floor (x*n))/ (float) n; 
  float x1 = (ceil  (x*n))/ (float) n;
  float y0 = x0; 
  float y1 = x1; 

  float px = 0.5*(x0+x1) + aa/n;
  float py = 0.5*(x0+x1) - aa/n;

  float y = 0;
  if ((x < px) && (x > x0)) {
    y = fit(x, x0, px, y0, py);
  } 
  else {
    y = fit(x, px, x1, py, y1);
  }

  return y;
}

//=====================================================================================================================================================================================================
//=====================================================================================================================================================================================================
//=====================================================================================================================================================================================================
// TESTED ABOVE HERE
//=====================================================================================================================================================================================================
//=====================================================================================================================================================================================================
//=====================================================================================================================================================================================================

float function_QuadraticBezierStaircase (float x, a; int n) {
  string functionName = "Quadratic Bezier Staircase";

  float aa = (a - 0.5);
  if (aa == 0) {
    return x;
  }

  float x0 = (floor (x*n))/ float(n); 
  float x1 = (ceil  (x*n))/ float(n);
  float y0 = x0; 
  float y1 = x1; 

  float px = 0.5*(x0+x1) + aa/n;
  float py = 0.5*(x0+x1) - aa/n;

  float p0x = (x0 + px)/2.0;
  float p0y = (y0 + py)/2.0;
  float p1x = (x1 + px)/2.0;
  float p1y = (y1 + py)/2.0;
  

  float y = 0;
  float denom = (1.0/n)*0.5;
  
  if ((x <= p0x) && (x >= x0)) {
    // left side
    if (floor (x*n) <= 0){
      y = fit(x, x0, px, y0, py);
    } else {
      
      if (abs(x - x0) < M_E){
        // problem when x == x0 !
      }
      
      float za = (x0  - (p1x - 1.0/n))/denom; 
      float zb = (y0  - (p1y - 1.0/n))/denom; 
      float zx = ( x  - (p1x - 1.0/n))/denom; 
      float om2a = 1.0 - 2.0*za;
      
      float interior = max (0, za*za + om2a*zx);
      float t = (sqrt(interior) - za)/om2a;
      float zy = (1.0-2.0*zb)*(t*t) + (2*zb)*t;
      zy *= (p1y - p0y);
      zy += p1y; //(p1y - 1.0/n);
      if (x > x0){
        zy -= 1.0/n;
      }
      y = zy;
    }
  } 

  else if ((x >= p1x) && (x <= x1)) {
    // right side
    if (ceil  (x*n) >= n) {
      y = fit(x, px, x1, py, y1);
    } 
    else {
      if (abs(x - x1) < M_E){
        // problem when x == x1 !
      }
      
      float za = (x1 - p1x)/denom; 
      float zb = (y1 - p1y)/denom; 
      float zx = ( x - p1x)/denom; 
      if (za == 0.5) {
        za += M_E;
      }
      float om2a = 1.0 - 2.0*za;
      if (abs(om2a) < M_E) {
        om2a = ((om2a < 0) ? -1:1) * M_E;
      }
      
      float interior = max (0, za*za + om2a*zx);
      float t = (sqrt(interior) - za)/om2a;
      float zy = (1.0-2.0*zb)*(t*t) + (2*zb)*t;
      zy *= (p1y - p0y);
      zy += p1y;
      y = zy;
    }
  } 

  else {
    // center
    float za = (px - p0x)/denom; 
    float zb = (py - p0y)/denom; 
    float zx = ( x - p0x)/denom; 
    if (za == 0.5) {
      za += M_E;
    }
    float om2a = 1.0 - 2.0*za;
    float t = (sqrt(za*za + om2a*zx) - za)/om2a;
    float zy = (1.0-2.0*zb)*(t*t) + (2*zb)*t;
    zy *= (p1y - p0y);
    zy += p0y;
    y = zy;
  }
  return y;

}

// Symmetric Double-Element Sigmoids

//------------------------------------------------------------------
float function_DoubleExponentialSigmoid (float x, a){
  string functionName = "Double-Exponential Sigmoid";
  
  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  float aa = clamp(a, min_param_a, max_param_a); 
  aa = 1-aa;
  
  float y = 0;
  if (x<=0.5){
    y = (pow(2.0*x, 1.0/aa))/2.0;
  } 
  else {
    y = 1.0 - (pow(2.0*(1.0-x), 1.0/aa))/2.0;
  }
  return y;
}



//------------------------------------------------------------------
float function_AdjustableCenterDoubleExponentialSigmoid (float x, a, b){
  string functionName = "Adjustable-Center Double-Exponential Sigmoid";
  
  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  a = clamp(a, min_param_a, max_param_a); 
  a = 1-a;
  
  float y = 0;
  float w = max(0, min(1, x-(b-0.5)));
  if (w<=0.5){
    y = (pow(2.0*w, 1.0/a))/2.0;
  } 
  else {
    y = 1.0 - (pow(2.0*(1.0-w), 1.0/a))/2.0;
  }
  return y;
}



//------------------------------------------------------------------
float function_DoubleQuadraticSigmoid (float x){
  string functionName = "Double-Quadratic Sigmoid";

  float y = 0;
  if (x<=0.5){
    y = sq(2.0*x)/2.0;
  } 
  else {
    y = 1.0 - sq(2.0*(x-1.0))/2.0;
  }
  return y;
}


//------------------------------------------------------------------
float function_DoublePolynomialSigmoid (float x; int n){
  string functionName = "Double-Polynomial Sigmoid";

  float y = 0;
  if (n%2 == 0){ 
    // even polynomial
    if (x<=0.5){
      y = pow(2.0*x, n)/2.0;
    } 
    else {
      y = 1.0 - pow(2*(x-1.0), n)/2.0;
    }
  } 
  
  else { 
    // odd polynomial
    if (x<=0.5){
      y = pow(2.0*x, n)/2.0;
    } 
    else {
      y = 1.0 + pow(2.0*(x-1.0), n)/2.0;
    }

  }

  return y;
}

//------------------------------------------------------------------
float function_DoubleEllipticOgee (float x, a, b){
  string functionName = "Double-Elliptic Ogee";

  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  float aa = clamp(a, min_param_a, max_param_a); 
  float y = 0;

  if (x<=aa){
    y = (b/aa) * sqrt(pow(aa, 2) - pow(x-aa, 2));
  } 
  else {
    y = 1.0 - ((1.0-b)/(1.0-aa))*sqrt(pow(1.0-aa, 2) - pow(x-aa, 2));
  }
  return y;
}

//------------------------------------------------------------------
float function_AdjustableCenterEllipticWindow (float x, a){
  string functionName = "Adjustable-Center Elliptic Window";
  
  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  float aa = clamp(a, min_param_a, max_param_a);
  
  float y = 0;

  if (x<=aa){
    y = (1.0/aa) * sqrt(sq(aa) - sq(x-aa));
  } 
  else {
    y = (1.0/(1-aa)) * sqrt(sq(1.0-aa) - sq(x-aa));
  }
  return y;
}


//------------------------------------------------------------------
float function_AdjustableCenterHyperellipticWindow (float x, a; int n){
  string functionName = "Adjustable-Center Hyperelliptic Window";
  
  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  float aa = clamp(a, min_param_a, max_param_a);
  
  float y = 0;
  float pwn = n * 2.0; 

  if (x<=aa){
    y = (1.0/a) * pow( pow(aa, pwn)     - pow(x-aa, pwn), 1.0/pwn);
  } 
  else {
    y =  ((1.0/ (1-aa)))  * pow( pow(1.0-aa, pwn) - pow(x-aa, pwn), 1.0/pwn);
  }
  return y;
}

//------------------------------------------------------------------
float function_AdjustableCenterSquircularWindow (float x, a; int n){
  string functionName = "Adjustable-Center Squircular Window";
  
  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  float aa = clamp(a, min_param_a, max_param_a);
  
  float y = 0;
  float pwn = max(2, n * 2.0); 

  if (x<=a){
    y = (1-aa) + pow( pow(aa, pwn) - pow(x-aa, pwn), 1.0/pwn);
  } 
  else {
    y = aa + pow( pow(1.0-aa, pwn) - pow(x-aa, pwn), 1.0/pwn);
  }
  return y;
}






// Double-Cubic Seat 

//------------------------------------------------------------------
float function_DoubleCubicOgee (float x, a, b){
  string functionName = "Double-Cubic Ogee";
  
  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  float min_param_b = 0.0;
  float max_param_b = 1.0;

  float aa = clamp(a, min_param_a, max_param_a); 
  float bb = clamp(b, min_param_b, max_param_b); 
  float y = 0;
  if (x <= aa){
    y = bb - bb*pow(1.0-x/aa, 3.0);
  } 
  else {
    y = bb + (1.0-bb)*pow((x-aa)/(1.0-aa), 3.0);
  }
  return y;
}
//------------------------------------------------------------------
float function_DoubleCircularSigmoid (float x, a) {
  string functionName = "Double-Circular Sigmoid";
  
  float y = 0;
  if (x<=a) {
    y = a - sqrt(a*a - x*x);
  } 
  else {
    y = a + sqrt(sq(1.0-a) - sq(x-1.0));
  }
  return y;
}

//------------------------------------------------------------------
float function_DoubleSquircularSigmoid (float x, a; int n) {
  string functionName = "Double-Squircular Sigmoid";
 
  float pwn = max(2, n * 2.0); 
  float y = 0;
  if (x<=a) {
    y = a - pow( pow(a,pwn) - pow(x,pwn), 1.0/pwn);
  } 
  else {
    y = a + pow(pow(1.0-a, pwn) - pow(x-1.0, pwn), 1.0/pwn);
  }
  return y;
}


//------------------------------------------------------------------
float function_CircularEaseIn (float x) {
  string functionName = "Circular Ease In";
  float y = 1.0 - sqrt(1.0 - x*x);
  return y;
}

//------------------------------------------------------------------
float function_CircularEaseOut (float x) {
  string functionName = "Circular Ease Out";
  float y = sqrt(1.0 - sq(1.0 - x));
  return y;
}


//------------------------------------------------------------------
float function_CircularEaseInOut (float x) {
  string functionName = "Penner's Circular Ease InOut";
  float y = 0; 
  float x2 = x * 2.0;
  
  if (x2 < 1) {
    y =  -0.5 * (sqrt(1.0 - x2*x2) - 1.0);
  } else {
    x2 -= 2.0;
    y =   0.5 * (sqrt(1.0 - x2*x2) + 1.0);
  }
  
  return y;
}


//------------------------------------------------------------------
float function_DoubleQuadraticBezier (float x, a, b, c, d) {
  string functionName = "Double Quadratic Bezier";
  // also see http://engineeringtraining.tpub.com/14069/css/14069_150.htm
  // produces mysterious values when a=0,b=1,c=0.667,d=0.417
  
  float xmid = (a + c)/2.0; 
  float ymid = (b + d)/2.0; 
  xmid = clamp (xmid, M_E, 1.0-M_E);
  ymid = clamp (ymid, M_E, 1.0-M_E);
  
  float y = 0;
  float om2a;
  float t; 
  float xx; 
  float aa; 
  float bb;

  if (x <= xmid){
    xx = x / xmid;
    aa = a / xmid; 
    bb = b / ymid; 
    om2a = 1.0 - 2.0*aa;
    if (om2a == 0) {
       om2a = M_E; 
    }   
    t = (sqrt(aa*aa + om2a*xx) - aa)/om2a;
    y = (1.0-2.0*bb)*(t*t) + (2*bb)*t;
    y *= ymid;
  }
  else {
     xx = (x - xmid)/(1.0-xmid);
     aa = (c - xmid)/(1.0-xmid); 
     bb = (d - ymid)/(1.0-ymid); 
     om2a = 1.0 - 2.0*aa;
     if (om2a == 0) {
       om2a = M_E; 
     }     
     t = (sqrt(aa*aa + om2a*xx) - aa)/om2a;
     y = (1.0-2.0*bb)*(t*t) + (2*bb)*t;
     y *= (1.0 - ymid); 
     y += ymid;
  }

  return y; 
}
// Double-Elliptic Sigmoid

//------------------------------------------------------------------
float function_DoubleEllipticSigmoid (float x, a, b){
  string functionName = "Double-Elliptic Sigmoid";

  float y = 0;
  if (x<=a){
    if (a <= 0){
      y = 0;
    } else {
      y = b * (1.0 - (sqrt(sq(a) - sq(x))/a));
    }
  } 
  else {
    if (a >= 1){
      y = 1.0;
    } else {
      y = b + ((1.0-b)/(1.0-a))*sqrt(sq(1.0-a) - sq(x-1.0));
    }
  }
  return y;
}
// Simplified Double-Cubic Seat

//------------------------------------------------------------------
float function_DoubleCubicOgeeSimplified (float x, a, b){
  string functionName = "Simplified Double-Cubic Ogee";
  float bb = 1 - b; //reverse, for intelligibility.
  
  float y = 0;
  if (x<=a){
    if (a <= 0){
      y = 0; 
    } else {
      float val = 1 - x/a;
      y = bb*x + (1-bb)*a*(1.0- val*val*val);
    }
  } 
  else {
    if (a >= 1){
      y = 1;
    } else {
      float val = (x-a)/(1-a);
      y = bb*x + (1-bb)*(a + (1-a)* val*val*val);
    }
  }

  return y;
}

//=====================================================================================================================================================================================================
//=====================================================================================================================================================================================================
//=====================================================================================================================================================================================================
// TESTED ABOVE HERE
//=====================================================================================================================================================================================================
//=====================================================================================================================================================================================================
//=====================================================================================================================================================================================================



//------------------------------------------------------------------
float function_RaisedInvertedCosine (float x) {
  string functionName = "Raised Inverted Cosine";

  float y = (1.0 - cos(M_PI*x))/2.0;
  return y;
}

//------------------------------------------------------------------
float function_BlinnWyvillCosineApproximation (float x) {
  string functionName = "Blinn/Wyvill's Cosine Approximation";

  float x2 = x*x;
  float x4 = x2*x2;
  float x6 = x4*x2;
  float fa = ( 4.0/9.0);
  float fb = (17.0/9.0);
  float fc = (22.0/9.0);
  float y = fa*x6 - fb*x4 + fc*x2;

  return y;
}

//------------------------------------------------------------------
float function_SmoothStep (float x) { 
  // http://en.wikipedia.org/wiki/Smoothstep
  string functionName = "Smooth Step";

  return x*x*(3.0 - 2.0*x);
}

//------------------------------------------------------------------
float function_SmootherStep (float x) { 
  // http://en.wikipedia.org/wiki/Smoothstep
  string functionName = "Perlin's Smoother Step";

  return x*x*x*(x*(x*6.0 - 15.0) + 10.0);
}

//------------------------------------------------------------------
float function_MaclaurinCos (float x) {
  // http://blogs.ubc.ca/infiniteseriesmodule/units/unit-3-power-series/taylor-series/the-maclaurin-expansion-of-cosx/

  string functionName = "Maclaurin Cosine Approximation";
  int nTerms = 6; // anything less is fouled
  float x_temp = x;
  x_temp *= M_PI;
  float xp = 1.0;
  float x2 = x_temp*x_temp;

  float sig  = 1.0;
  float fact = 1.0;
  float out = xp;

  for (int i=0; i<nTerms; i++) {
    xp   *= x2; 
    sig  = 0-sig;
    fact *= (i*2+1); 
    fact *= (i*2+2);
    out  += sig * (xp / fact);
  }

  out = (1.0 - out)/2.0;
  return out;
}

//------------------------------------------------------------------
// from http://paulbourke.net/miscellaneous/interpolation/
float function_CatmullRomInterpolate (float x, a, b) {
  string functionName = "Catmull-Rom Interpolation";

  float y0 = a; 
  float y3 = b; 
  float x2 = x*x;

  float a0 = -0.5*y0 + 0.5*y3 - 1.5 ;
  float a1 =      y0 - 0.5*y3 + 2.0 ;
  float a2 = -0.5*y0          + 0.5 ;

  float out = a0*x*x2 + a1*x2 + a2*x;
  return clamp (out, 0, 1);
}


//------------------------------------------------------------------
// from http://musicdsp.org/showArchiveComment.php?ArchiveID=93
// by Laurent de Soras
float function_Hermite (float x, a, b, c, d) {
  string functionName = "Hermite (de Soras)";
  a = fit(a, 0,1, -1,1);
  c = fit(c, 0,1, -1,1);
  
  float hC = (c - a) * 0.5f;
  float hV = (b - d);
  float hW = hC + hV;
  float hA = hW + hV + (c - b) * 0.5f;
  float hB = hW + hA;

  return ((((hA * x) - hB) * x + hC) * x + b);
}


//------------------------------------------------------------------
// from http://paulbourke.net/miscellaneous/interpolation/
float function_Hermite2 (float x, a, b, c, d) {
  string functionName = "Hermite (Bourke)";

  // Tension: 1 is high, 0 normal, -1 is low
  // Bias: 0 is even, positive is towards first segment, negative towards the other

  float tension = fit (c, 0,1, -1,1); 
  float bias    = fit (d, 0,1, -1,1); 

  float y0 = 2.0 * (a - 0.5);  //? a
  float y1 = 0.0; 
  float y2 = 1.0; 
  float y3 = b;

  float x2 =  x * x;
  float x3 = x2 * x;

  float m0, m1;
  m0  = (y1-y0)*(1.0+bias)*(1.0-tension)/2.0;
  m0 += (y2-y1)*(1.0-bias)*(1.0-tension)/2.0;
  m1  = (y2-y1)*(1.0+bias)*(1.0-tension)/2.0;
  m1 += (y3-y2)*(1.0-bias)*(1.0-tension)/2.0;

  float a0  =  2.0*x3 - 3.0*x2 + 1.0;
  float a1  =      x3 - 2.0*x2 + x;
  float a2  =      x3 -     x2;
  float a3  = -2.0*x3 + 3.0*x2;

  return (a0*y1 + a1*m0 + a2*m1 + a3*y2);
}

//------------------------------------------------------------------
float function_NormalizedErf (float x) {
  // http://en.wikipedia.org/wiki/Error_function
  // Note that this implementation is a shifted, scaled and normalized error function!
  string functionName = "Error Function";
  
  float erfBound = 2.0; // set bounds for artificial "normalization"
  float erfBoundNorm = 0.99532226501; // this = erf(2.0), i.e., erf(erfBound)
  float z = fit(x, 0.0, 1.0, 0-erfBound, erfBound); 

  float z2 = z*z; 
  float a = (8.0*(M_PI-3.0)) / ((3*M_PI)*(4.0-M_PI)); 
  float out = sqrt (1.0 - exp(0 - z2*(  (a*z2 + 4.0/M_PI) / (a*z2 + 1.0))));
  if (z < 0.0) out = 0-out;

  out /= erfBoundNorm;
  out = (out+1.0) / 2.0; 

  return out;
}

//------------------------------------------------------------------
float function_NormalizedInverseErf (float x) {
  // http://en.wikipedia.org/wiki/Error_function
  // Note that this implementation is a shifted, scaled and normalized error function!
  string functionName = "Inverse Error Function";

  float erfBound = 2.0;
  float erfBoundNorm = 0.99532226501; // this = erf(2.0), i.e., erf(erfBound)
  float z = fit(x, 0, 1, -erfBoundNorm, erfBoundNorm); 
  float z2 = z*z;
  float a = (8.0*(M_PI-3.0)) / ((3*M_PI)*(4.0-M_PI)); 

  float A = (2.0 / (M_PI *a)) + (log(1.0-z2) / 2.0);
  float B = (log(1.0-z2) / a);
  float out = sqrt( sqrt(A*A - B) - A );

  if (z < 0.0) out = 0-out;
  out /= erfBound; 
  out = (out+1.0); 
  out /= 2.0;

  out = clamp(out, 0, 1);  // necessary
  return out;
}

//------------------------------------------------------------------
float function_SimpleHalfGaussian (float x) {
  // http://en.wikipedia.org/wiki/Gaussian_function
  string functionName = "Simple Gaussian (Half)";

  float sigma = 0.25; // produces results < 0.001 at f(0); 
  float out = exp(0.0 - (sq(x-1.0) / (2.0*sigma*sigma))); 
  return out;
}

//------------------------------------------------------------------
float function_AdjustableFwhmHalfGaussian (float x, a) {
  // http://en.wikipedia.org/wiki/Gaussian_function
  // http://en.wikipedia.org/wiki/Full_width_at_half_maximum
  string functionName = "Adjustable-FWHM Gaussian (Half)";

  float denom = sqrt(2.0*log(2.0));
  float sigma = (1.0 - a) / denom;

  // 68.26894921371
  float out = exp(0.0 - (sq(x-1.0) / (2.0*sigma*sigma))); 
  return out;
}

//------------------------------------------------------------------
float function_HalfGaussianThroughAPoint (float x, a, b) {
  // http://en.wikipedia.org/wiki/Gaussian_function
  // http://en.wikipedia.org/wiki/Full_width_at_half_maximum
  string functionName = "Gaussian Through A Point (Half)";
  
  b = max(0.0000001, b); 
  float denom = sqrt(2.0*log(1.0/b));
  float sigma = (1.0 - a) / denom;

  // 68.26894921371
  float out = exp(0.0 - (sq(x-1.0) / (2.0*sigma*sigma))); 
  return out;
}

//------------------------------------------------------------------
float function_AdjustableSigmaHalfGaussian (float x, a) {
  // http://en.wikipedia.org/wiki/Gaussian_function
  string functionName = "Adjustable-Sigma Gaussian (Half)";

  float sigma = 1.0-a;
  float out = exp(0.0 - (sq(x-1.0) / (2.0*sigma*sigma))); 
  return out;
}

//------------------------------------------------------------------
float function_HalfLanczosSincWindow (float x) {
//   // http://en.wikipedia.org/wiki/Window_function 
//   string functionName = "Lanczos Sinc Window (Half)";
   float y = sinc(1.0 - x);
   return y;
}

//------------------------------------------------------------------
float function_HalfNuttallWindow (float x) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Nuttall Window (Half)";

  float a0 = 0.355768;
  float a1 = 0.487396;
  float a2 = 0.144232;
  float a3 = 0.012604;

  float x2 = x * 0.5;
  float pix = M_PI*x2;
  float y = a0 - a1*cos(2*pix) + a2*cos(4*pix) - a3*cos(6*pix);
  return y;
}

//------------------------------------------------------------------
float function_HalfBlackmanNuttallWindow (float x) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Blackman–Nuttall Window (Half)";

  float a0 = 0.3635819;
  float a1 = 0.4891775;
  float a2 = 0.1365995;
  float a3 = 0.0106411;

  float x2 = x*0.5;
  float pix = M_PI*x2;
  float y = a0 - a1*cos(2*pix) + a2*cos(4*pix) - a3*cos(6*pix);
  return y;
}

//------------------------------------------------------------------
float function_HalfBlackmanHarrisWindow (float x) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Blackman–Harris Window (Half)";

  float a0 = 0.35875;
  float a1 = 0.48829;
  float a2 = 0.14128;
  float a3 = 0.01168;

  float x2 = x*0.5;
  float pix = M_PI*x2;
  float y = a0 - a1*cos(2*pix) + a2*cos(4*pix) - a3*cos(6*pix);
  return y;
}

//------------------------------------------------------------------
float function_HalfExactBlackmanWindow (float x) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Exact Blackman Window (Half)";

  float a0 = 7938.0 / 18608.0;
  float a1 = 9240.0 / 18608.0;
  float a2 = 1430.0 / 18608.0;

  float x2 = x*0.5;
  float pix = M_PI*x2;
  float y = a0 - a1*cos(2*pix) + a2*cos(4*pix);
  return y;
}

//------------------------------------------------------------------
float function_HalfGeneralizedBlackmanWindow (float x, a) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Generalized Blackman Window (Half)";

  float a0 = (1.0 - a)/2.0;
  float a1 = 0.5;
  float a2 = a / 2.0;

  float x2 = x*0.5;
  float pix = M_PI*x2;
  float y = a0 - a1*cos(2*pix) + a2*cos(4*pix);
  return y;
}

//------------------------------------------------------------------
float function_HalfFlatTopWindow (float x) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Flat Top Window (Half)";

  float a0 = 1.000;
  float a1 = 1.930;
  float a2 = 1.290;
  float a3 = 0.388;
  float a4 = 0.032;

  float x2 = x*0.5;
  float pix = M_PI*x2;
  float y = a0 - a1*cos(2*pix) + a2*cos(4*pix) - a3*cos(6*pix) + a4*cos(8*pix);
  y /= (a0 + a1 + a2 + a3 + a4); 

  return y;
}

//------------------------------------------------------------------
float function_HalfBartlettHannWindow (float x) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Bartlett-Hann Window (Half)";

  float a0 = 0.62;
  float a1 = 0.48;
  float a2 = 0.38;

  float x2 = x*0.5;
  float y = a0 - a1*abs(x2 - 0.5) - a2*cos(2*M_PI*x2);
  return y;
}

//------------------------------------------------------------------
float function_BartlettWindow (float x) {
  // http://en.wikipedia.org/wiki/Window_function 
  // Triangular window with zero-valued end-points:
  string functionName = "Bartlett (Triangle) Window";

  float y = 2.0 * (0.5 - abs(x - 0.5));
  return y;
}

//------------------------------------------------------------------
float function_TukeyWindow (float x, a) {
  string functionName = "Tukey Window";
  // http://en.wikipedia.org/wiki/Window_function 
  // The Tukey window, also known as the tapered cosine window, 
  // can be regarded as a cosine lobe of width \tfrac{\alpha N}{2} 
  // that is convolved with a rectangle window of width \left(1 -\tfrac{\alpha}{2}\right)N.  
  // At alpha=0 it becomes rectangular, and at alpha=1 it becomes a Hann window.

  float ah = a/2.0; 
  float omah = 1.0 - ah;

  float y = 1.0;
  if (x <= ah) {
    y = 0.5 * (1.0 + cos(M_PI* ((2*x/a) - 1.0)));
  } 
  else if (x > omah) {
    y = 0.5 * (1.0 + cos(M_PI* ((2*x/a) - (2/a) + 1.0)));
  } 
  return y;
}

//------------------------------------------------------------------
float function_AdjustableCenterCosineWindow (float x, a) {
  string functionName = "Adjustable Center Cosine Window";
  
  float ah = a/2.0; 
  float omah = 1.0 - ah;

  float y = 1.0;
  if (x <= a) {
    y = 0.5 * (1.0 + cos(M_PI* ((x/a) - 1.0)));
  } 
  else {
    y = 0.5 * (1.0 + cos(M_PI* (((x-a)/(1.0-a))  )));
  } 
  return y;
}

//------------------------------------------------------------------
float function_CosineWindow (float x) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Cosine Window";

  float y = sin (M_PI*x);
  return y;
}

//------------------------------------------------------------------
float function_AdjustableSigmaGaussian (float x, a) {
  // http://en.wikipedia.org/wiki/Gaussian_function
  string functionName = "Adjustable-Sigma Gaussian Window";
 
  float x2 = x*2;
  float a2 = a*2;
  float sigma = a2;
  float out = exp(0.0 - (sq(x2-1.0) / (2.0*sigma*sigma))); 
  return out;
}

//------------------------------------------------------------------
float function_SlidingAdjustableSigmaGaussian (float x, a, b) {
  // http://en.wikipedia.org/wiki/Gaussian_function
  string functionName = "Sliding Adjustable-Sigma Gaussian Window";
  float x2 = x*2;
  float b2 = b*2;

  float sigma = b2;
  float dx = 2.0*(a - 0.5); 
  float out = exp(0.0 - (sq(x2-1.0 -dx) / (2.0*sigma*sigma))); 
  return out;
}

//------------------------------------------------------------------
float function_LanczosSincWindow (float x) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Lanczos Sinc Window";

  float y = sinc(1.0 - x*2);
  return y;
}

//------------------------------------------------------------------
float function_NuttallWindow (float x) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Nuttall Window";

  float a0 = 0.355768;
  float a1 = 0.487396;
  float a2 = 0.144232;
  float a3 = 0.012604;

  float pix = M_PI*x;
  float y = a0 - a1*cos(2*pix) + a2*cos(4*pix) - a3*cos(6*pix);
  return y;
}

//------------------------------------------------------------------
float function_BlackmanNuttallWindow (float x) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Blackman–Nuttall Window";

  float a0 = 0.3635819;
  float a1 = 0.4891775;
  float a2 = 0.1365995;
  float a3 = 0.0106411;

  float pix = M_PI*x;
  float y = a0 - a1*cos(2*pix) + a2*cos(4*pix) - a3*cos(6*pix);
  return y;
}


//------------------------------------------------------------------
float function_BlackmanHarrisWindow (float x) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Blackman–Harris Window";

  float a0 = 0.35875;
  float a1 = 0.48829;
  float a2 = 0.14128;
  float a3 = 0.01168;

  float pix = M_PI*x;
  float y = a0 - a1*cos(2*pix) + a2*cos(4*pix) - a3*cos(6*pix);
  return y;
}


//------------------------------------------------------------------
float function_ExactBlackmanWindow (float x) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Exact Blackman Window";

  float a0 = 7938.0 / 18608.0;
  float a1 = 9240.0 / 18608.0;
  float a2 = 1430.0 / 18608.0;

  float pix = M_PI*x;
  float y = a0 - a1*cos(2*pix) + a2*cos(4*pix);
  return y;
}


//------------------------------------------------------------------
float function_GeneralizedBlackmanWindow (float x, a) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Generalized Blackman Window";

  float a0 = (1.0 - a)/2.0;
  float a1 = 0.5;
  float a2 = a / 2.0;

  float pix = M_PI*x;
  float y = a0 - a1*cos(2*pix) + a2*cos(4*pix);
  return y;
}


//------------------------------------------------------------------
float function_FlatTopWindow (float x) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Flat Top Window";

  float a0 = 1.000;
  float a1 = 1.930;
  float a2 = 1.290;
  float a3 = 0.388;
  float a4 = 0.032;

  float pix = M_PI*x;
  float y = a0 - a1*cos(2*pix) + a2*cos(4*pix) - a3*cos(6*pix) + a4*cos(8*pix);
  y /= (a0 + a1 + a2 + a3 + a4); 

  return y;
}

//------------------------------------------------------------------
float function_BartlettHannWindow (float x) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Bartlett-Hann Window";

  float a0 = 0.62;
  float a1 = 0.48;
  float a2 = 0.38;

  float y = a0 - a1*abs(x - 0.5) - a2*cos(2*M_PI*x);
  return y;
}

//------------------------------------------------------------------
float function_HannWindow (float x){
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Hann (Raised Cosine) Window";

  float y = 0.5 * (1.0 - cos(2*M_PI*x));
  return y;
}

//------------------------------------------------------------------
float function_HammingWindow (float x){
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Hamming Window";

  float y = 0.54 - 0.46*cos(2*M_PI*x);
  return y;
}

//=======================================================================================================================================================================================================================
//=======================================================================================================================================================================================================================
//=======================================================================================================================================================================================================================
//=======================================================================================================================================================================================================================


//------------------------------------------------------------------
float function_GeneralizedTriangleWindow (float x, a) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Generalized Triangle Window";
 
  float y = 0; 
  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  a = clamp(a, min_param_a, max_param_a); 
  
  if (x < a){
    y = (x / a); 
  } else {
    y = 1.0 - ((x-a)/(1.0-a));
  }
  return y;
}

//------------------------------------------------------------------
float function_PoissonWindow (float x, a) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Poisson or Exponential Window";

  float EPS = 0.00001;
  float tau = max(a, EPS); 
  
  float y = exp (0.0 - (abs(x - 0.5))*(1.0/tau));
  return y; 
}

//------------------------------------------------------------------
float function_HannPoissonWindow (float x, a) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Hann-Poisson Window";

  float EPS = 0.00001;
  float tau = 25.0 * max(a*a*a*a, EPS); // nice control
  
  float hy = 0.5 * (1.0 - cos(2*M_PI*x));
  float py = exp (0.0 - (abs(x - 0.5))*(1.0/tau));
  return (hy * py); 
}

//------------------------------------------------------------------
float function_HannPoissonWindowSliding (float x, a, b) {
  // http://en.wikipedia.org/wiki/Window_function 
  string functionName = "Sliding Hann-Poisson Window";

  float EPS = 0.00001;
  float tau = 25.0 * max(b*b*b*b, EPS); // nice range of control
  
  float newx = clamp(x + (0.5 - a), 0, 1); 
  float hy = 0.5 * (1.0 - cos(2*M_PI*newx));
  float py = exp (0.0 - (abs(newx - 0.5))*(1.0/tau));
  return (hy * py); 
}


// Exponential shapers

float function_ExponentialEmphasis (float x, a) {
  string functionName = "Exponential Emphasis";

  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  a = clamp(a, min_param_a, max_param_a); 

  if (a < 0.5) {
    // emphasis
    a = 2*(a);
    float y = pow(x, a);
    return y;
  } 
  else {
    // de-emphasis
    a = 2*(a-0.5);
    float y = pow(x, 1.0/(1-a));
    return y;
  }
}

//------------------------------------------------------------------
float function_IterativeSquareRoot (float x) {
  // http://en.wikipedia.org/wiki/Methods_of_computing_square_roots
  // Ancient Babylonian technology
  string functionName = "Iterative (Heron's) Square Root";
  float y = 0.5; 
  int n = 6;
  for (int i=0; i<n; i++) {
    y = (y + x/y)/2.0;
  }
  return y;
}

//------------------------------------------------------------------
// float function_FastSquareRoot(float x) {
//   // http://en.wikipedia.org/wiki/Fast_inverse_square_root
//   // http://stackoverflow.com/questions/11513344/how-to-implement-the-fast-inverse-square-root-in-java
//   string functionName = "FastSquareRoot";
  
//   float xhalf = 0.5f * x;
//   int i = Float.floatToIntBits(x);
//   i = 0x5f3759df - (i>>1);
//   x = Float.intBitsToFloat(i);
//   x = x*(1.5f - xhalf*x*x);
//   return 1.0/x;
// }

// Symmetric Double-Exponential Seat

//------------------------------------------------------------------
float function_DoubleExponentialOgee (float x, a){
  string functionName = "Double-Exponential Ogee";

  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  float aa = clamp(a, min_param_a, max_param_a); 

  float y = 0;
  if (x<=0.5){
    y = (pow(2.0*x, 1.0-aa))/2.0;
  } 
  else {
    y = 1.0 - (pow(2.0*(1.0-x), 1.0-aa))/2.0;
  }
  return y;
}
// Joining Two Lines with a Circular Arc Fillet
// Adapted from Robert D. Miller / Graphics Gems III.

// ====================================================================
float function_CircularFillet (float x, a, b, c) {
  string functionName = "Double-Linear with Circular Fillet";

  float arcStartAngle;
  float arcEndAngle;
  float arcStartX, arcStartY;
  float arcEndX, arcEndY;
  float arcCenterX, arcCenterY;
  float arcRadius;

  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  float min_param_b = 0.0 + M_E;
  float max_param_b = 1.0 - M_E;
  float aa = clamp(a, min_param_a, max_param_a); 
  float bb = clamp(b, min_param_b, max_param_b); 

  float R = c;
  computeFilletParameters (0, 0, aa, bb, aa, bb, 1, 1, R);

  float t = 0;
  float y = 0;
  x = clamp(x, 0, 1); 

  if (x <= arcStartX) {
    if (arcStartX < M_E){
      y = 0;
    } else {
      t = x / arcStartX;
      y = t * arcStartY;
    }
  } 
  else if (x >= arcEndX) {
    t = (x - arcEndX)/(1 - arcEndX);
    y = arcEndY + t*(1 - arcEndY);
  } 
  else {
    if (x >= arcCenterX) {
      y = arcCenterY - sqrt(sq(arcRadius) - sq(x-arcCenterX));
    } 
    else {
      y = arcCenterY + sqrt(sq(arcRadius) - sq(x-arcCenterX));
    }
  }
  return y;
}


// ====================================================================
// Return signed distance from line Ax + By + C = 0 to point P.
float linetopoint (float a, b, c, ptx, pty) {
  float lp = 0.0;
  float d = sqrt((a*a)+(b*b));
  if (d != 0.0) {
    lp = (a*ptx + b*pty + c)/d;
  }
  return lp;
}

// ====================================================================
// Compute the paramters of a circular arc fillet between lines L1 (p1 to p2) and
// L2 (p3 to p4) with radius R.  
// 
void computeFilletParameters (float p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y, r) {
  float arcStartAngle;
  float arcEndAngle;
  float arcStartX, arcStartY;
  float arcEndX, arcEndY;
  float arcCenterX, arcCenterY;
  float arcRadius;


  float c1   = p2x*p1y - p1x*p2y;
  float a1   = p2y-p1y;
  float b1   = p1x-p2x;
  float c2   = p4x*p3y - p3x*p4y;
  float a2   = p4y-p3y;
  float b2   = p3x-p4x;
  if ((a1*b2) == (a2*b1)) {  /* Parallel or coincident lines */
    return;
  }

  float d1, d2;
  float mPx, mPy;
  mPx= (p3x + p4x)/2.0;
  mPy= (p3y + p4y)/2.0;
  d1 = linetopoint(a1, b1, c1, mPx, mPy);  /* Find distance p1p2 to p3 */
  if (d1 == 0.0) {
    return;
  }
  mPx= (p1x + p2x)/2.0;
  mPy= (p1y + p2y)/2.0;
  d2 = linetopoint(a2, b2, c2, mPx, mPy);  /* Find distance p3p4 to p2 */
  if (d2 == 0.0) {
    return;
  }

  float c1p, c2p, d;
  float rr = r;
  if (d1 <= 0.0) {
    rr= -rr;
  }
  c1p = c1 - rr*sqrt((a1*a1)+(b1*b1));  /* Line parallel l1 at d */
  rr = r;
  if (d2 <= 0.0) {
    rr = -rr;
  }
  c2p = c2 - rr*sqrt((a2*a2)+(b2*b2));  /* Line parallel l2 at d */
  d = (a1*b2)-(a2*b1);

  float pCx = (c2p*b1-c1p*b2)/d;                /* Intersect constructed lines */
  float pCy = (c1p*a2-c2p*a1)/d;                /* to find center of arc */
  float pAx = 0;
  float pAy = 0;
  float pBx = 0;
  float pBy = 0;
  float dP, cP;

  dP = (a1*a1) + (b1*b1);              /* Clip or extend lines as required */
  if (dP != 0.0) {
    cP = a1*pCy - b1*pCx;
    pAx = (-a1*c1 - b1*cP)/dP;
    pAy = ( a1*cP - b1*c1)/dP;
  }
  dP = (a2*a2) + (b2*b2);
  if (dP != 0.0) {
    cP = a2*pCy - b2*pCx;
    pBx = (-a2*c2 - b2*cP)/dP;
    pBy = ( a2*cP - b2*c2)/dP;
  }

  float gv1x = pAx-pCx; 
  float gv1y = pAy-pCy;
  float gv2x = pBx-pCx; 
  float gv2y = pBy-pCy;

  float arcStart = (float) atan2(gv1y, gv1x); 
  float arcAngle = 0.0;
  float dd = (float) sqrt(((gv1x*gv1x)+(gv1y*gv1y)) * ((gv2x*gv2x)+(gv2y*gv2y)));
  if (dd != (float) 0.0) {
    arcAngle = (acos((gv1x*gv2x + gv1y*gv2y)/dd));
  } 
  float crossProduct = (gv1x*gv2y - gv2x*gv1y);
  if (crossProduct < 0.0) { 
    arcStart -= arcAngle;
  }

  float arc1 = arcStart;
  float arc2 = arcStart + arcAngle;
  if (crossProduct < 0.0) {
    arc1 = arcStart + arcAngle;
    arc2 = arcStart;
  }

  arcCenterX    = pCx;
  arcCenterY    = pCy;
  arcStartAngle = arc1;
  arcEndAngle   = arc2;
  arcRadius     = r;
  arcStartX = arcCenterX + arcRadius*cos(arcStartAngle);
  arcStartY = arcCenterY + arcRadius*sin(arcStartAngle);
  arcEndX   = arcCenterX + arcRadius*cos(arcEndAngle);
  arcEndY   = arcCenterY + arcRadius*sin(arcEndAngle);
}


//==============================================================
float function_CircularArcThroughAPoint (float x, a, b){
  string functionName = "Circular Arc Through a Given Point";
  float m_Centerx;
  float m_Centery;
  float m_dRadius;

  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  float min_param_b = 0.0 + M_E;
  float max_param_b = 1.0 - M_E;
  float aa = clamp(a, min_param_a, max_param_a); 
  float bb = clamp(b, min_param_b, max_param_b); 
  x = clamp(x, 0+M_E,1-M_E);
  
  float pt1x = 0;
  float pt1y = 0;
  float pt2x = aa;
  float pt2y = bb;
  float pt3x = 1;
  float pt3y = 1;

  if      (!IsPerpendicular(pt1x,pt1y, pt2x,pt2y, pt3x,pt3y) )  calcCircleFrom3Points (pt1x,pt1y, pt2x,pt2y, pt3x,pt3y);  
  else if (!IsPerpendicular(pt1x,pt1y, pt3x,pt3y, pt2x,pt2y) )  calcCircleFrom3Points (pt1x,pt1y, pt3x,pt3y, pt2x,pt2y);  
  else if (!IsPerpendicular(pt2x,pt2y, pt1x,pt1y, pt3x,pt3y) )  calcCircleFrom3Points (pt2x,pt2y, pt1x,pt1y, pt3x,pt3y);  
  else if (!IsPerpendicular(pt2x,pt2y, pt3x,pt3y, pt1x,pt1y) )  calcCircleFrom3Points (pt2x,pt2y, pt3x,pt3y, pt1x,pt1y);  
  else if (!IsPerpendicular(pt3x,pt3y, pt2x,pt2y, pt1x,pt1y) )  calcCircleFrom3Points (pt3x,pt3y, pt2x,pt2y, pt1x,pt1y);  
  else if (!IsPerpendicular(pt3x,pt3y, pt1x,pt1y, pt2x,pt2y) )  calcCircleFrom3Points (pt3x,pt3y, pt1x,pt1y, pt2x,pt2y);  
  else { 
    return 0;
  }
  //------------------
  // clamp
  if ((m_Centerx > 0) && (m_Centerx < 1)){
     if (a < m_Centerx){
       m_Centerx = 1;
       m_Centery = 0;
       m_dRadius = 1;
     } else {
       m_Centerx = 0;
       m_Centery = 1;
       m_dRadius = 1;
     }
  }
  
  
  //------------------
  float y = 0;
  if (x >= m_Centerx){
    y = m_Centery - sqrt(sq(m_dRadius) - sq(x-m_Centerx)); 
  } 
  else{
    y = m_Centery + sqrt(sq(m_dRadius) - sq(x-m_Centerx)); 
  }
  return y;
}

//==============================================================
int IsPerpendicular( float pt1x, pt1y, pt2x, pt2y, pt3x, pt3y)
{
  // Check the given point are perpendicular to x or y axis 
  float yDelta_a = pt2y - pt1y;
  float xDelta_a = pt2x - pt1x;
  float yDelta_b = pt3y - pt2y;
  float xDelta_b = pt3x - pt2x;

  // checking whether the line of the two pts are vertical
  if (abs(xDelta_a) <= M_E && abs(yDelta_b) <= M_E){
    return 0;
  }
  if (abs(yDelta_a) <= M_E){
    return 1;
  }
  else if (abs(yDelta_b) <= M_E){
    return 1;
  }
  else if (abs(xDelta_a)<= M_E){
    return 1;
  }
  else if (abs(xDelta_b)<= M_E){
    return 1;
  }
  else return 0;
}


//==============================================================
void calcCircleFrom3Points (float pt1x, pt1y, pt2x, pt2y, pt3x, pt3y) {
  float m_Centerx;
  float m_Centery;
  float m_dRadius;

  float yDelta_a = pt2y - pt1y;
  float xDelta_a = pt2x - pt1x;
  float yDelta_b = pt3y - pt2y;
  float xDelta_b = pt3x - pt2x;

  if (abs(xDelta_a) <= M_E && abs(yDelta_b) <= M_E){
    m_Centerx = 0.5*(pt2x + pt3x);
    m_Centery = 0.5*(pt1y + pt2y);
    m_dRadius = sqrt(sq(m_Centerx-pt1x) + sq(m_Centery-pt1y));
    return;
  }

  // IsPerpendicular() assure that xDelta(s) are not zero
  float aSlope = yDelta_a / xDelta_a; 
  float bSlope = yDelta_b / xDelta_b;
  if (abs(aSlope-bSlope) <= M_E){ // checking whether the given points are colinear.  
    return;
  }

  // calc center
  m_Centerx = (aSlope*bSlope*(pt1y - pt3y) + bSlope*(pt1x + pt2x)- aSlope*(pt2x+pt3x) )/(2* (bSlope-aSlope) );
  m_Centery = -1*(m_Centerx - (pt1x+pt2x)/2)/aSlope +  (pt1y+pt2y)/2;
  m_dRadius = sqrt(sq(m_Centerx-pt1x) + sq(m_Centery-pt1y));
}

// Bezier Shapers
// adapted from BEZMATH.PS (1993)
// by Don Lancaster, SYNERGETICS Inc. 
// http://www.tinaja.com/text/bezmath.html

//------------------------------------------------------------------
float function_QuadraticBezier (float x, a, b){
  string functionName = "Quadratic Bezier";

  float min_param_a = 0.0;
  float max_param_a = 1.0;
  float min_param_b = 0.0;
  float max_param_b = 1.0;
  float aa = clamp(a, min_param_a, max_param_a); 
  float bb = clamp(b, min_param_b, max_param_b); 

  if (aa == 0.5){
    aa += M_E;
  }
  // solve t from x (an inverse operation)
  float om2a = 1.0 - 2.0*aa;
  float t = (sqrt(aa*aa + om2a*x) - aa)/om2a;
  float y = (1.0-2.0*bb)*(t*t) + (2*bb)*t;
  return y;
}


//------------------------------------------------------------------
float function_CubicBezier (float x, a, b, c, d){
  string functionName = "Cubic Bezier";

  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  float min_param_b = 0.0;
  float max_param_b = 1.0;
  float min_param_c = 0.0 + M_E;
  float max_param_c = 1.0 - M_E;
  float min_param_d = 0.0;
  float max_param_d = 1.0;
  float aa = clamp(a, min_param_a, max_param_a); 
  float bb = clamp(b, min_param_b, max_param_b); 
  float cc = clamp(c, min_param_c, max_param_c); 
  float dd = clamp(d, min_param_d, max_param_d); 

  //-------------------------------------------
  float y0a = 0.00; // initial y
  float x0a = 0.00; // initial x 
  float y1a = bb;    // 1st influence y   
  float x1a = aa;    // 1st influence x 
  float y2a = dd;    // 2nd influence y
  float x2a = cc;    // 2nd influence x
  float y3a = 1.00; // y 
  float x3a = 1.00; // x 

  float A =   x3a - 3*x2a + 3*x1a - x0a;
  float B = 3*x2a - 6*x1a + 3*x0a;
  float C = 3*x1a - 3*x0a;   
  float D =   x0a;

  float E =   y3a - 3*y2a + 3*y1a - y0a;    
  float F = 3*y2a - 6*y1a + 3*y0a;             
  float G = 3*y1a - 3*y0a;             
  float H =   y0a;

  // Solve for t given x (using Newton-Raphelson), then solve for y given t.
  // Assume for the first guess that t = x.
  float currentt = x;
  int nRefinementIterations = 5;
  for (int i=0; i<nRefinementIterations; i++){
    float currentx = xFromT (currentt, A,B,C,D); 
    float currentslope = slopeFromT (currentt, A,B,C);
    currentt -= (currentx - x)*(currentslope);
    currentt = clamp(currentt, 0,1.0);
  } 
 
  //------------
  float y = yFromT (currentt, E,F,G,H);
  return y;
}


//==========================================================
float slopeFromT (float t, A, B, C){
  float dtdx = 1.0/(3.0*A*t*t + 2.0*B*t + C); 
  return dtdx;
}
//==========================================================
float xFromT (float t, A, B, C, D){
  float x = A*(t*t*t) + B*(t*t) + C*t + D;
  return x;
}
//==========================================================
float yFromT (float t, E, F, G, H){
  float y = E*(t*t*t) + F*(t*t) + G*t + H;
  return y;
}
// Parabola (Quadratic) Through a Point
//------------------------------------------------------------------
float function_ParabolaThroughAPoint (float x, a, b){
  string functionName = "Quadratic Through a Given Point";
  
  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  float min_param_b = 0.0;
  float max_param_b = 1.0;
  float aa = clamp(a, min_param_a, max_param_a); 
  float bb = clamp(b, min_param_b, max_param_b); 
  
  float A = (1-bb)/(1-aa) - (bb/aa);
  float B = (A*(aa*aa)-bb)/aa;
  float y = A*(x*x) - B*(x);
  y = clamp(y, 0,1); 
  
  return y;
}


//------------------------------------------------------------------
// generalized damped sinusoid
float function_DampedSinusoid (float x, a){
  // http://en.wikipedia.org/wiki/Damped_sine_wave
  string functionName = "Generalized Damped Sinusoid";
  
  float omega  = 100*a;
  float lambda = -6.90775527; // ln(lambda) = 0.001 // decay constant
  float phi = 0;
  float e = 2.718281828459045;
  
  float t = x;
  float y = pow(e, lambda*t) * cos(omega*t + phi);
  return y;
}

//------------------------------------------------------------------
// generalized damped sinusoid
float function_DampedSinusoidReverse (float x, a){
  // http://en.wikipedia.org/wiki/Damped_sine_wave
  string functionName = "Generalized Damped Sinusoid (Reverse)";
  
  float omega = 100*a;
  float lambda = -6.90775527; // ln(lambda) = 0.001
  float phi = 0;
  float e = 2.718281828459045;
  
  float t = 1.0-x;
  float y = pow(e, lambda*t) * cos(omega*t + phi);
  return y;
}


//------------------------------------------------------------------
float function_CubicBezierThrough2Points (float x, a, b, c, d){
  string functionName = "Cubic Bezier (Nearly) Through 2 Points"; 

  float y = 0;

  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  float min_param_b = 0.0 + M_E;
  float max_param_b = 1.0 - M_E;
  float aa = clamp(a, min_param_a, max_param_a); 
  float bb = clamp(b, min_param_b, max_param_b); 

  float x0 = 0;  
  float y0 = 0;
  float x4 = aa;  
  float y4 = bb;
  float x5 = c;  
  float y5 = d;
  float x3 = 1;  
  float y3 = 1;
  float x1,y1,x2,y2; // to be solved.

  float t1 = 0.3;
  float t2 = 0.7;

  float B0t1 = B0(t1);
  float B1t1 = B1(t1);
  float B2t1 = B2(t1);
  float B3t1 = B3(t1);
  float B0t2 = B0(t2);
  float B1t2 = B1(t2);
  float B2t2 = B2(t2);
  float B3t2 = B3(t2);

  float ccx = x4 - x0*B0t1 - x3*B3t1;
  float ccy = y4 - y0*B0t1 - y3*B3t1;
  float ffx = x5 - x0*B0t2 - x3*B3t2;
  float ffy = y5 - y0*B0t2 - y3*B3t2;

  x2 = (ccx - (ffx*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);
  y2 = (ccy - (ffy*B1t1)/B1t2) / (B2t1 - (B1t1*B2t2)/B1t2);
  x1 = (ccx - x2*B2t1) / B1t1;
  y1 = (ccy - y2*B2t1) / B1t1;

  x1 = clamp(x1, 0+M_E,1-M_E); 
  x2 = clamp(x2, 0+M_E,1-M_E); 

  y = function_CubicBezier(x, x1,y1, x2,y2);
  y = clamp(y,0,1); 
  
  string functionName = "Cubic Bezier (Nearly) Through 2 Points";  
  return y;
}

//==============================================================
float B0 (float t){
  return (1-t)*(1-t)*(1-t);
}
float B1 (float t){
  return  3*t* (1-t)*(1-t);
}
float B2 (float t){
  return 3*t*t* (1-t);
}
float B3 (float t){
  return t*t*t;
}
float  findx (float t, x0, x1, x2, x3){
  return x0*B0(t) + x1*B1(t) + x2*B2(t) + x3*B3(t);
}
float  findy (float t, y0, y1, y2, y3){
  return y0*B0(t) + y1*B1(t) + y2*B2(t) + y3*B3(t);
}


//------------------------------------------------------------------
float function_DoubleCircularOgee (float x, a){
  string functionName = "Double-Circular Ogee";
  
  float min_param_a = 0.0;
  float max_param_a = 1.0;
  
  float aa = clamp(a, min_param_a, max_param_a); 
  float y = 0;
  if (x<=aa){
    y = sqrt(sq(aa) - sq(x-aa));
  } 
  else {
    y = 1 - sqrt(sq(1-aa) - sq(x-aa));
  }
  return y;
}


float function_DoubleSquircularOgee (float x, a; int n){
  // http://en.wikipedia.org/wiki/Squircle
  string functionName = "Double-Squircular Ogee";
  
  float min_param_a = 0.0;
  float max_param_a = 1.0;
  float aa = clamp(a, min_param_a, max_param_a); 
  float pown = 2.0 * n; 
  
  float y = 0;
  if (x<=aa){
    y = pow( pow(a,pown) - pow(x-aa, pown), 1.0/pown);
  } 
  else {
    y = 1.0 - pow( pow(1-aa, pown) - pow(x-aa, pown), 1.0/pown);
  }
  return y;
}
// Modified (Normalized) Logistic Sigmoid 

//------------------------------------------------------------------
float function_GeneralSigmoidLogitCombo (float x, a, b){
  
  float y = 0; 
  if (a < 0.5){
    // Logit
    float dy = b - 0.5;
    y = dy + function_NormalizedLogit (x, 1.0-(2.0*a));
  } else {
    // Sigmoid
    float dx = b - 0.5;
    y = function_NormalizedLogisticSigmoid (x+dx, (2.0*(a-0.5)));
  }
  
  string functionName = "General Sigmoid-Logit Combination";
  y = clamp(y, 0,1); 
  return y;
}

//------------------------------------------------------------------
float function_NormalizedLogisticSigmoid (float x, a) {
  string functionName = "Normalized Logistic Sigmoid";

  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  float emph = 5.0;

  float aa = clamp(a, min_param_a, max_param_a);
  aa = (1.0/(1.0-aa) - 1.0); 
  aa = emph * aa;

  float y    = 1.0 / (1.0 + exp(0 - (x-0.5)*aa));
  float miny = 1.0 / (1.0 + exp(  0.5*aa));
  float maxy = 1.0 / (1.0 + exp( -0.5*aa));
  y = fit(y, miny, maxy, 0, 1); 
  return y;
}


//------------------------------------------------------------------
float function_NormalizedLogit (float x, a) {
  // http://en.wikipedia.org/wiki/Logit
  string functionName = "Normalized Logit Function";

  float min_param_a = 0.0 + M_E;
  float max_param_a = 1.0 - M_E;
  float emph = 5.0;

  float aa = clamp(a, min_param_a, max_param_a); 
  aa = (1/(1-aa) - 1); 
  aa = emph * aa;

  float minx = 1.0 / (1.0 + exp(  0.5*a    ));
  float maxx = 1.0 / (1.0 + exp( -0.5*a    ));
  x = fit(x, 0,1, minx, maxx);

  float y = log ( x / (1.0 - x)) ;
  y *= 1.0/a; 
  y += 0.5;

  y = clamp (y, 0, 1); 
  return y;
}

// A Flexible Quartic Equation

//------------------------------------------------------------------
float function_NiftyQuartic (float x, a, b) {
  string functionName = "Quartic";

  float min_param_a = 0.0;
  float max_param_a = 1.0;
  float min_param_b = 0.0;
  float max_param_b = 1.0;
  float aa = clamp(a, min_param_a, max_param_a); 
  float bb = clamp(b, min_param_b, max_param_b);

  aa = 1.0-aa;
  float w = (1-2*aa)*(x*x) + (2*aa)*x;
  float y = (1-2*bb)*(w*w) + (2*bb)*w;
  return y;
}


float function_Identity (float x) {
  string functionName = "Identity Function";
  return x;
}

float function_Inverse (float x) {
  string functionName = "Inverse Function";
  return 1.0-x;
}

float function_BoxcarFunction (float x){
  // http://mathworld.wolfram.com/BoxcarFunction.html
  // Also see http://mathworld.wolfram.com/HeavisideStepFunction.html
  string functionName = "Boxcar Function";
  if (x < 0.5){
    return 0.0; 
  } else if (x > 0.5){
    return 1.0; 
  } 
  return 0.5;
}